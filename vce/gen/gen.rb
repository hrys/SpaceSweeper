#
# DO NOT MODIFY!!!!
# This file is automatically generated by Racc 1.4.12
# from Racc grammer file "".
#

###### racc/parser.rb begin
unless $".index 'racc/parser.rb'
$".push 'racc/parser.rb'
#
# $Id: a7af944d201a32a63d2536cdd589d8e9910848e0 $
#
# Copyright (c) 1999-2006 Minero Aoki
#
# This program is free software.
# You can distribute/modify this program under the same terms of ruby.
#
# As a special exception, when this code is copied by Racc
# into a Racc output file, you may use that output file
# without restriction.
#

require 'racc/info'

unless defined?(NotImplementedError)
  NotImplementedError = NotImplementError # :nodoc:
end

module Racc
  class ParseError < StandardError; end
end
unless defined?(::ParseError)
  ParseError = Racc::ParseError
end

# Racc is a LALR(1) parser generator.
# It is written in Ruby itself, and generates Ruby programs.
#
# == Command-line Reference
#
#     racc [-o<var>filename</var>] [--output-file=<var>filename</var>]
#          [-e<var>rubypath</var>] [--embedded=<var>rubypath</var>]
#          [-v] [--verbose]
#          [-O<var>filename</var>] [--log-file=<var>filename</var>]
#          [-g] [--debug]
#          [-E] [--embedded]
#          [-l] [--no-line-convert]
#          [-c] [--line-convert-all]
#          [-a] [--no-omit-actions]
#          [-C] [--check-only]
#          [-S] [--output-status]
#          [--version] [--copyright] [--help] <var>grammarfile</var>
#
# [+filename+]
#   Racc grammar file. Any extention is permitted.
# [-o+outfile+, --output-file=+outfile+]
#   A filename for output. default is <+filename+>.tab.rb
# [-O+filename+, --log-file=+filename+]
#   Place logging output in file +filename+.
#   Default log file name is <+filename+>.output.
# [-e+rubypath+, --executable=+rubypath+]
#   output executable file(mode 755). where +path+ is the Ruby interpreter.
# [-v, --verbose]
#   verbose mode. create +filename+.output file, like yacc's y.output file.
# [-g, --debug]
#   add debug code to parser class. To display debuggin information,
#   use this '-g' option and set @yydebug true in parser class.
# [-E, --embedded]
#   Output parser which doesn't need runtime files (racc/parser.rb).
# [-C, --check-only]
#   Check syntax of racc grammer file and quit.
# [-S, --output-status]
#   Print messages time to time while compiling.
# [-l, --no-line-convert]
#   turns off line number converting.
# [-c, --line-convert-all]
#   Convert line number of actions, inner, header and footer.
# [-a, --no-omit-actions]
#   Call all actions, even if an action is empty.
# [--version]
#   print Racc version and quit.
# [--copyright]
#   Print copyright and quit.
# [--help]
#   Print usage and quit.
#
# == Generating Parser Using Racc
#
# To compile Racc grammar file, simply type:
#
#   $ racc parse.y
#
# This creates Ruby script file "parse.tab.y". The -o option can change the output filename.
#
# == Writing A Racc Grammar File
#
# If you want your own parser, you have to write a grammar file.
# A grammar file contains the name of your parser class, grammar for the parser,
# user code, and anything else.
# When writing a grammar file, yacc's knowledge is helpful.
# If you have not used yacc before, Racc is not too difficult.
#
# Here's an example Racc grammar file.
#
#   class Calcparser
#   rule
#     target: exp { print val[0] }
#
#     exp: exp '+' exp
#        | exp '*' exp
#        | '(' exp ')'
#        | NUMBER
#   end
#
# Racc grammar files resemble yacc files.
# But (of course), this is Ruby code.
# yacc's $$ is the 'result', $0, $1... is
# an array called 'val', and $-1, $-2... is an array called '_values'.
#
# See the {Grammar File Reference}[rdoc-ref:lib/racc/rdoc/grammar.en.rdoc] for
# more information on grammar files.
#
# == Parser
#
# Then you must prepare the parse entry method. There are two types of
# parse methods in Racc, Racc::Parser#do_parse and Racc::Parser#yyparse
#
# Racc::Parser#do_parse is simple.
#
# It's yyparse() of yacc, and Racc::Parser#next_token is yylex().
# This method must returns an array like [TOKENSYMBOL, ITS_VALUE].
# EOF is [false, false].
# (TOKENSYMBOL is a Ruby symbol (taken from String#intern) by default.
# If you want to change this, see the grammar reference.
#
# Racc::Parser#yyparse is little complicated, but useful.
# It does not use Racc::Parser#next_token, instead it gets tokens from any iterator.
#
# For example, <code>yyparse(obj, :scan)</code> causes
# calling +obj#scan+, and you can return tokens by yielding them from +obj#scan+.
#
# == Debugging
#
# When debugging, "-v" or/and the "-g" option is helpful.
#
# "-v" creates verbose log file (.output).
# "-g" creates a "Verbose Parser".
# Verbose Parser prints the internal status when parsing.
# But it's _not_ automatic.
# You must use -g option and set +@yydebug+ to +true+ in order to get output.
# -g option only creates the verbose parser.
#
# === Racc reported syntax error.
#
# Isn't there too many "end"?
# grammar of racc file is changed in v0.10.
#
# Racc does not use '%' mark, while yacc uses huge number of '%' marks..
#
# === Racc reported "XXXX conflicts".
#
# Try "racc -v xxxx.y".
# It causes producing racc's internal log file, xxxx.output.
#
# === Generated parsers does not work correctly
#
# Try "racc -g xxxx.y".
# This command let racc generate "debugging parser".
# Then set @yydebug=true in your parser.
# It produces a working log of your parser.
#
# == Re-distributing Racc runtime
#
# A parser, which is created by Racc, requires the Racc runtime module;
# racc/parser.rb.
#
# Ruby 1.8.x comes with Racc runtime module,
# you need NOT distribute Racc runtime files.
#
# If you want to include the Racc runtime module with your parser.
# This can be done by using '-E' option:
#
#   $ racc -E -omyparser.rb myparser.y
#
# This command creates myparser.rb which `includes' Racc runtime.
# Only you must do is to distribute your parser file (myparser.rb).
#
# Note: parser.rb is LGPL, but your parser is not.
# Your own parser is completely yours.
module Racc

  unless defined?(Racc_No_Extentions)
    Racc_No_Extentions = false # :nodoc:
  end

  class Parser

    Racc_Runtime_Version = ::Racc::VERSION
    Racc_Runtime_Revision = '$Id: a7af944d201a32a63d2536cdd589d8e9910848e0 $'

    Racc_Runtime_Core_Version_R = ::Racc::VERSION
    Racc_Runtime_Core_Revision_R = '$Id: a7af944d201a32a63d2536cdd589d8e9910848e0 $'.split[1]
    begin
      if RUBY_ENGINE == 'jruby'
        require 'racc/cparse-jruby.jar'
        com.headius.racc.Cparse.new.load(JRuby.runtime, false)
      else
        require 'racc/cparse'
      end
    # Racc_Runtime_Core_Version_C  = (defined in extention)
      Racc_Runtime_Core_Revision_C = Racc_Runtime_Core_Id_C.split[2]
      unless new.respond_to?(:_racc_do_parse_c, true)
        raise LoadError, 'old cparse.so'
      end
      if Racc_No_Extentions
        raise LoadError, 'selecting ruby version of racc runtime core'
      end

      Racc_Main_Parsing_Routine    = :_racc_do_parse_c # :nodoc:
      Racc_YY_Parse_Method         = :_racc_yyparse_c # :nodoc:
      Racc_Runtime_Core_Version    = Racc_Runtime_Core_Version_C # :nodoc:
      Racc_Runtime_Core_Revision   = Racc_Runtime_Core_Revision_C # :nodoc:
      Racc_Runtime_Type            = 'c' # :nodoc:
    rescue LoadError
puts $!
puts $!.backtrace
      Racc_Main_Parsing_Routine    = :_racc_do_parse_rb
      Racc_YY_Parse_Method         = :_racc_yyparse_rb
      Racc_Runtime_Core_Version    = Racc_Runtime_Core_Version_R
      Racc_Runtime_Core_Revision   = Racc_Runtime_Core_Revision_R
      Racc_Runtime_Type            = 'ruby'
    end

    def Parser.racc_runtime_type # :nodoc:
      Racc_Runtime_Type
    end

    def _racc_setup
      @yydebug = false unless self.class::Racc_debug_parser
      @yydebug = false unless defined?(@yydebug)
      if @yydebug
        @racc_debug_out = $stderr unless defined?(@racc_debug_out)
        @racc_debug_out ||= $stderr
      end
      arg = self.class::Racc_arg
      arg[13] = true if arg.size < 14
      arg
    end

    def _racc_init_sysvars
      @racc_state  = [0]
      @racc_tstack = []
      @racc_vstack = []

      @racc_t = nil
      @racc_val = nil

      @racc_read_next = true

      @racc_user_yyerror = false
      @racc_error_status = 0
    end

    # The entry point of the parser. This method is used with #next_token.
    # If Racc wants to get token (and its value), calls next_token.
    #
    # Example:
    #     def parse
    #       @q = [[1,1],
    #             [2,2],
    #             [3,3],
    #             [false, '$']]
    #       do_parse
    #     end
    #
    #     def next_token
    #       @q.shift
    #     end
    def do_parse
      __send__(Racc_Main_Parsing_Routine, _racc_setup(), false)
    end

    # The method to fetch next token.
    # If you use #do_parse method, you must implement #next_token.
    #
    # The format of return value is [TOKEN_SYMBOL, VALUE].
    # +token-symbol+ is represented by Ruby's symbol by default, e.g. :IDENT
    # for 'IDENT'.  ";" (String) for ';'.
    #
    # The final symbol (End of file) must be false.
    def next_token
      raise NotImplementedError, "#{self.class}\#next_token is not defined"
    end

    def _racc_do_parse_rb(arg, in_debug)
      action_table, action_check, action_default, action_pointer,
      _,            _,            _,              _,
      _,            _,            token_table,    * = arg

      _racc_init_sysvars
      tok = act = i = nil

      catch(:racc_end_parse) {
        while true
          if i = action_pointer[@racc_state[-1]]
            if @racc_read_next
              if @racc_t != 0   # not EOF
                tok, @racc_val = next_token()
                unless tok      # EOF
                  @racc_t = 0
                else
                  @racc_t = (token_table[tok] or 1)   # error token
                end
                racc_read_token(@racc_t, tok, @racc_val) if @yydebug
                @racc_read_next = false
              end
            end
            i += @racc_t
            unless i >= 0 and
                   act = action_table[i] and
                   action_check[i] == @racc_state[-1]
              act = action_default[@racc_state[-1]]
            end
          else
            act = action_default[@racc_state[-1]]
          end
          while act = _racc_evalact(act, arg)
            ;
          end
        end
      }
    end

    # Another entry point for the parser.
    # If you use this method, you must implement RECEIVER#METHOD_ID method.
    #
    # RECEIVER#METHOD_ID is a method to get next token.
    # It must 'yield' the token, which format is [TOKEN-SYMBOL, VALUE].
    def yyparse(recv, mid)
      __send__(Racc_YY_Parse_Method, recv, mid, _racc_setup(), false)
    end

    def _racc_yyparse_rb(recv, mid, arg, c_debug)
      action_table, action_check, action_default, action_pointer,
      _,            _,            _,              _,
      _,            _,            token_table,    * = arg

      _racc_init_sysvars

      catch(:racc_end_parse) {
        until i = action_pointer[@racc_state[-1]]
          while act = _racc_evalact(action_default[@racc_state[-1]], arg)
            ;
          end
        end
        recv.__send__(mid) do |tok, val|
          unless tok
            @racc_t = 0
          else
            @racc_t = (token_table[tok] or 1)   # error token
          end
          @racc_val = val
          @racc_read_next = false

          i += @racc_t
          unless i >= 0 and
                 act = action_table[i] and
                 action_check[i] == @racc_state[-1]
            act = action_default[@racc_state[-1]]
          end
          while act = _racc_evalact(act, arg)
            ;
          end

          while !(i = action_pointer[@racc_state[-1]]) ||
                ! @racc_read_next ||
                @racc_t == 0  # $
            unless i and i += @racc_t and
                   i >= 0 and
                   act = action_table[i] and
                   action_check[i] == @racc_state[-1]
              act = action_default[@racc_state[-1]]
            end
            while act = _racc_evalact(act, arg)
              ;
            end
          end
        end
      }
    end

    ###
    ### common
    ###

    def _racc_evalact(act, arg)
      action_table, action_check, _, action_pointer,
      _,            _,            _, _,
      _,            _,            _, shift_n,
      reduce_n,     * = arg
      nerr = 0   # tmp

      if act > 0 and act < shift_n
        #
        # shift
        #
        if @racc_error_status > 0
          @racc_error_status -= 1 unless @racc_t == 1   # error token
        end
        @racc_vstack.push @racc_val
        @racc_state.push act
        @racc_read_next = true
        if @yydebug
          @racc_tstack.push @racc_t
          racc_shift @racc_t, @racc_tstack, @racc_vstack
        end

      elsif act < 0 and act > -reduce_n
        #
        # reduce
        #
        code = catch(:racc_jump) {
          @racc_state.push _racc_do_reduce(arg, act)
          false
        }
        if code
          case code
          when 1 # yyerror
            @racc_user_yyerror = true   # user_yyerror
            return -reduce_n
          when 2 # yyaccept
            return shift_n
          else
            raise '[Racc Bug] unknown jump code'
          end
        end

      elsif act == shift_n
        #
        # accept
        #
        racc_accept if @yydebug
        throw :racc_end_parse, @racc_vstack[0]

      elsif act == -reduce_n
        #
        # error
        #
        case @racc_error_status
        when 0
          unless arg[21]    # user_yyerror
            nerr += 1
            on_error @racc_t, @racc_val, @racc_vstack
          end
        when 3
          if @racc_t == 0   # is $
            throw :racc_end_parse, nil
          end
          @racc_read_next = true
        end
        @racc_user_yyerror = false
        @racc_error_status = 3
        while true
          if i = action_pointer[@racc_state[-1]]
            i += 1   # error token
            if  i >= 0 and
                (act = action_table[i]) and
                action_check[i] == @racc_state[-1]
              break
            end
          end
          throw :racc_end_parse, nil if @racc_state.size <= 1
          @racc_state.pop
          @racc_vstack.pop
          if @yydebug
            @racc_tstack.pop
            racc_e_pop @racc_state, @racc_tstack, @racc_vstack
          end
        end
        return act

      else
        raise "[Racc Bug] unknown action #{act.inspect}"
      end

      racc_next_state(@racc_state[-1], @racc_state) if @yydebug

      nil
    end

    def _racc_do_reduce(arg, act)
      _,          _,            _,            _,
      goto_table, goto_check,   goto_default, goto_pointer,
      nt_base,    reduce_table, _,            _,
      _,          use_result,   * = arg

      state = @racc_state
      vstack = @racc_vstack
      tstack = @racc_tstack

      i = act * -3
      len       = reduce_table[i]
      reduce_to = reduce_table[i+1]
      method_id = reduce_table[i+2]
      void_array = []

      tmp_t = tstack[-len, len] if @yydebug
      tmp_v = vstack[-len, len]
      tstack[-len, len] = void_array if @yydebug
      vstack[-len, len] = void_array
      state[-len, len]  = void_array

      # tstack must be updated AFTER method call
      if use_result
        vstack.push __send__(method_id, tmp_v, vstack, tmp_v[0])
      else
        vstack.push __send__(method_id, tmp_v, vstack)
      end
      tstack.push reduce_to

      racc_reduce(tmp_t, reduce_to, tstack, vstack) if @yydebug

      k1 = reduce_to - nt_base
      if i = goto_pointer[k1]
        i += state[-1]
        if i >= 0 and (curstate = goto_table[i]) and goto_check[i] == k1
          return curstate
        end
      end
      goto_default[k1]
    end

    # This method is called when a parse error is found.
    #
    # ERROR_TOKEN_ID is an internal ID of token which caused error.
    # You can get string representation of this ID by calling
    # #token_to_str.
    #
    # ERROR_VALUE is a value of error token.
    #
    # value_stack is a stack of symbol values.
    # DO NOT MODIFY this object.
    #
    # This method raises ParseError by default.
    #
    # If this method returns, parsers enter "error recovering mode".
    def on_error(t, val, vstack)
      raise ParseError, sprintf("\nparse error on value %s (%s)",
                                val.inspect, token_to_str(t) || '?')
    end

    # Enter error recovering mode.
    # This method does not call #on_error.
    def yyerror
      throw :racc_jump, 1
    end

    # Exit parser.
    # Return value is Symbol_Value_Stack[0].
    def yyaccept
      throw :racc_jump, 2
    end

    # Leave error recovering mode.
    def yyerrok
      @racc_error_status = 0
    end

    # For debugging output
    def racc_read_token(t, tok, val)
      @racc_debug_out.print 'read    '
      @racc_debug_out.print tok.inspect, '(', racc_token2str(t), ') '
      @racc_debug_out.puts val.inspect
      @racc_debug_out.puts
    end

    def racc_shift(tok, tstack, vstack)
      @racc_debug_out.puts "shift   #{racc_token2str tok}"
      racc_print_stacks tstack, vstack
      @racc_debug_out.puts
    end

    def racc_reduce(toks, sim, tstack, vstack)
      out = @racc_debug_out
      out.print 'reduce '
      if toks.empty?
        out.print ' <none>'
      else
        toks.each {|t| out.print ' ', racc_token2str(t) }
      end
      out.puts " --> #{racc_token2str(sim)}"
      racc_print_stacks tstack, vstack
      @racc_debug_out.puts
    end

    def racc_accept
      @racc_debug_out.puts 'accept'
      @racc_debug_out.puts
    end

    def racc_e_pop(state, tstack, vstack)
      @racc_debug_out.puts 'error recovering mode: pop token'
      racc_print_states state
      racc_print_stacks tstack, vstack
      @racc_debug_out.puts
    end

    def racc_next_state(curstate, state)
      @racc_debug_out.puts  "goto    #{curstate}"
      racc_print_states state
      @racc_debug_out.puts
    end

    def racc_print_stacks(t, v)
      out = @racc_debug_out
      out.print '        ['
      t.each_index do |i|
        out.print ' (', racc_token2str(t[i]), ' ', v[i].inspect, ')'
      end
      out.puts ' ]'
    end

    def racc_print_states(s)
      out = @racc_debug_out
      out.print '        ['
      s.each {|st| out.print ' ', st }
      out.puts ' ]'
    end

    def racc_token2str(tok)
      self.class::Racc_token_to_s_table[tok] or
          raise "[Racc Bug] can't convert token #{tok} to string"
    end

    # Convert internal ID of token symbol to the string.
    def token_to_str(t)
      self.class::Racc_token_to_s_table[t]
    end

  end

end

end
###### racc/parser.rb end


class Gen < Racc::Parser

#
# gen_inner.rb
#
#
# Copyright (C) 2000-2005 Community Engine Inc. All rights reserved.
# For more information, please visit our website at www.ce-lab.net.
#

###########################################################################
# 初期化
###########################################################################


def initialize
  @identifier = '='
  @workbufsize = 65536
  @version = -1
  @idmax = 255
  @commandbits = 4
  @sizeofargs=0
  @currentid = 0
  @protocolname = "defaultproto"
  @protocolid = nil
  @serverconnection = :CONN
  @vpr = nil
  @enum = {}
  @enum_seq = 0
  @define = {}
  @static = {}
  @static_base  = {}
  @struct = {}
  @structname = []
  @s2c = []
  @c2s = []
  @q =[]
  @ids = {}
  @variable = {}
  @subversion = nil
  @printf_func = "vce_errout"
  @recvlimit={}
  @ifdef={}
  @sh = []
  @ch = []
  @cliclassmode = 0
end
attr_accessor :identifier, :workbufsize, :static, :static_base,
  :version, :idmax, :protocolname, :serverconnection, :ids, :struct, :structname,
  :enum, :define, :currentid, :s2c, :c2s, :q, :commandbits, :subversion,:sizeofargs,:recvlimit,:ifdef,
  :enum_typedefs, :protocolid, :vpr, :printf_func, :sh, :ch, :cliclassmode

RESERVED = {
  's2c'              => :S2C,
  'c2s'              => :C2S,
  'define'           => :DEFINE,
  'static'           => :STATIC,
  'enum'             => :ENUM,
  'protocolname'     => :PROTOCOLNAME,
  'idmax'            => :IDMAX,
  'workbufsize'      => :WORKBUFSIZE,
  'serverconnection' => :SERVERCONNECTION,
  'protocolid'       => :PROTOCOLID,
  'version'          => :VERSION,
  'sh'				 => :SH,
  'ch'				 => :CH,
  'cliclassmode'	 => :CLICLASSMODE, 
  'struct'           => :STRUCT,
  'recvlimit'        => :RECVLIMIT,
  'ifdef'            => :IFDEF,
  'char'             => :CHAR,
  'short'            => :SHORT,
  'int'              => :INT,
  'int64'            => :INT64,
  'float'            => :FLOAT,
  'uchar'             => :UCHAR,
  'ushort'            => :USHORT,
  'uint'              => :UINT,
  'uint64'            => :UINT64,
  'void'             => :VOID,
  'stringarray'      => :STRINGARRAY,
  'string'           => :STRING,
}
###########################################################################
# プロトコル定義を追加する。
###########################################################################
def add_proto( dest, fname, lineno, id, funcname, args)
  l = [ @s2c, @c2s]
  l.each do |p|
    p.each do |data|
      raise "#{fname}:#{lineno} Command ID #{id} is used again" if data['id'] == id
      raise "#{fname}:#{lineno} Too big ID : #{id} > #{@idmax}" if id > @idmax
    end
  end
  dest.push( { 'funcname' => funcname, 'id'=> id, 'args' => args})
end
###########################################################################
# enum に追加する。
###########################################################################
def add_enum( fname, line, typedef, name, expr)
  if @enum[name] or @define[name] then
    print "warning : #{fname}:#{line} redefined enum #{name}\n"
  end
  num = 0
  seq = -1
  unless expr then
    @enum.each do |key, value|
      if value[0] == typedef then
        if seq < value[2] then
          num = value[1] +1
          seq = value[2]
        end
      end
    end
  end
  @enum[name] = [typedef, expr ? expr: num, @enum_seq]
  @enum_seq += 1
end
###########################################################################
# define に追加する。
###########################################################################
def add_define( fname, line, name, expr)
  if @enum[name] or @define[name] or @static[name] then
    raise( GenError, "error : #{fname}:#{line} redefined define #{name}\n")
  end
  @define[name] = expr
end
###########################################################################
# static に追加する。
###########################################################################
def add_static( fname, line, name, expr)
  if @enum[name] or @static[name] or @define[name] then
    raise( GenError, "error : #{fname}:#{line} redefined static #{name}\n")
  end
  file=File.basename(fname,".*")
  @static[name] = expr
  @static_base[name] = file
end
###########################################################################
# 変数の値を取得する。
###########################################################################
def get_variables_value( fname, line, intern)
  if(@enum[intern])
    return @enum[intern][1]
  elsif(@define[intern])
    return @define[intern]
  elsif(@static[intern])
    return @static[intern]
  else
    raise( GenError, "#{fname}:#{line}: undefined #{intern.to_s}")
  end
#  return @enum[intern][1] if @enum[intern]
#  @define[intern] || raise( GenError, "#{fname}:#{line}: undefined #{intern.to_s}")
end
###########################################################################
# idmax をセットする。
###########################################################################
def set_idmax( id)
  @idmax = id
  if @idmax <= 255 then
    @commandbits = 1
  elsif @idmax <= 65535 then
    @commandbits = 2
  else
    @commandbits = 4
  end
end
###########################################################################
###########################################################################
def include_open( filename, lineno)
  dirs = [ "./"]
  @fname =~ /.*\//
  dirs.push( $&)
  dirs.each do |d|
    begin
      if File.stat( d + filename).file?
        parse_prepare( File.open( d + filename), d + filename)
        return
      end
    rescue
      next
    end
  end
  raise RuntimeError, "#{@fname}:#{lineno}: cannot find #{filename}"
end  
###########################################################################
# パースの前準備。字句解析ルーチン
###########################################################################
def parse_prepare( f, fname)
  @fname = fname
  @config_lines = []
  lineno = 1
  continueflag = false
  f.each do |line|
#    line.strip!
    # 指示行でない行は読み飛ばす。
    reg = Regexp::quote(@identifier)
    directive = line =~ /^#{reg}/ 
    if directive then
      line = $'
    else
      if continueflag then
      else
        lineno += 1
        next
      end
    end

    continueflag=false
    @config_lines.push( line)
    until line.empty? do
        case line
        when /\A\n/, /\A\r\n/
          # コメント
        when /\A\s+/, /\A\#.*/
          # include
        when /\Ainclude\s+"((?:[^"\\]+|\\.)*)"\s*/
          include_open( $1, lineno)
          @fname = fname

          #サーバー側に強制的に追加
        when /\Ash (.*)$/
	      text = $1.dup
#STDERR.print "test ", line ," :: test2 ", text, "::\n"
		  @q.push [ :SH, [lineno, text, fname ]]
          #クライアント側に強制的に追加
        when /\Ach (.*)$/
          text = $1.dup
          @q.push [ :CH, [lineno, text, fname ]]

          # 予約語
        when /\A[a-zA-Z_](\w|[\->\.])*/
          word = $&
          @q.push [ RESERVED[word] || :IDENT, [lineno, word.intern, fname]]
        when /\A[x\da-fA-F]+/
          @q.push [ :NUMBER, [lineno, eval($&), fname] ]
          # バックスラッシュは何もしない eval をしているのは，16進とか8進
          # とかをそのまま整数に変換するため
        when /\A("(?:[^"\\]+|\\.)*")\s*/
          @q.push [ :QSTR, [lineno, $1, fname] ]
        when /\A\\/
          continueflag = true
          # その他全て
        when /\A./
          @q.push [ $&, [lineno, $&, fname] ]
        else
          raise RuntimeError, 'must not happen'
        end
        line = $'
    end
    if continueflag != true then
      @q.push [ :EOL, [lineno, nil, fname]]
    end
    lineno += 1
  end
end
###########################################################################
# パースする。
###########################################################################
def jhash(str)
  result = 0
  mul = 1
  max_mod = 2**31 - 1

  str.chars.reverse_each do |c|
    result += mul * c.ord
    result %= max_mod
    mul *= 31
  end

  result  
end

def parse( f, fname)
  parse_prepare( f, fname)
  h = jhash(@config_lines.join( ""))
  @subversion = h % 1000000000

#  @q.each {|qq|
#    print "Q: #{qq}\n"
#  }
  if @q.size != 0 then
    @q.push [false, '$']
    do_parse
  end
  if @vpr then
    if @protocolid.nil? then
      raise GenError, "not found protocolid directive.\nYou have to set protocolid directive when you set to serverconnection vpr_circ."
    end
  end
end
###########################################################################
# 次のトークン
###########################################################################

def next_token
  @q.shift
end

###########################################################################
# エラーのとき。
###########################################################################
def on_error( t, v, values )
  if v then
    line = v[0]
    v = v[1]
  else
    line = 'last'
  end
  raise Racc::ParseError,
    "#{@fname}:#{line}: syntax error on #{v.inspect}"
end
class GenError < StandardError; end
class GenArgumentError < GenError; end


##### State transition tables begin ###

racc_action_table = [
    68,    69,    66,    67,    44,    44,    44,    44,    44,    44,
    45,    45,    45,    45,    45,    45,    63,    61,    46,    46,
    46,    46,    46,    46,    62,    60,   109,    43,    43,    43,
    43,    43,    43,   116,   110,   110,    44,    68,    69,    66,
    67,   124,    45,    47,    47,    47,    47,    47,    47,    44,
    46,    44,    68,    69,    44,    45,    44,    45,    54,    43,
    45,    80,    45,    46,    87,    46,    68,    69,    46,    81,
    46,    80,    43,   -19,    43,    47,    59,    43,    44,    43,
    44,    58,    57,    44,    45,    55,    45,    78,    47,    45,
    47,    77,    46,    47,    46,    47,    76,    46,    53,    50,
   103,    43,   101,    43,    49,    48,    43,    68,    69,    66,
    67,    68,    69,    66,    67,   101,    80,    47,    75,    47,
    74,    64,    47,    92,    93,    94,    95,    96,    97,    98,
    99,   100,   102,   106,   107,   101,    92,    93,    94,    95,
    96,    97,    98,    99,   100,   102,    68,    69,    66,    67,
    68,    69,    66,    67,    65,   112,    92,    93,    94,    95,
    96,    97,    98,    99,   100,   102,     4,     5,    22,    23,
   115,    24,    25,    26,    27,    28,    29,    30,   -19,    31,
    32,   117,    39,    33,    34,    35,    36,     4,     5,    22,
    23,   120,    24,    25,    26,    27,    28,    29,    30,   120,
    31,    32,    37,   120,    33,    34,    35,    36,    68,    69,
    66,    67,    68,    69,    66,    67,    68,    69,    66,    67,
    80 ]

racc_action_check = [
   122,   122,   122,   122,    74,    44,    50,    22,    66,    43,
    74,    44,    50,    22,    66,    43,    36,    35,    74,    44,
    50,    22,    66,    43,    36,    35,    89,    74,    44,    50,
    22,    66,    43,   105,    89,   105,    67,    70,    70,    70,
    70,   122,    67,    74,    44,    50,    22,    66,    43,    26,
    67,    27,    84,    84,    68,    26,    49,    27,    29,    67,
    68,    61,    49,    26,    70,    27,    83,    83,    68,    62,
    49,    63,    26,    65,    27,    67,    34,    68,    69,    49,
    31,    33,    32,   120,    69,    30,    31,    60,    26,   120,
    27,    59,    69,    68,    31,    49,    58,   120,    28,    25,
    77,    69,    75,    31,    24,    23,   120,    40,    40,    40,
    40,    88,    88,    88,    88,    80,    81,    69,    57,    31,
    53,    37,   120,    75,    75,    75,    75,    75,    75,    75,
    75,    75,    75,    80,    80,   110,    80,    80,    80,    80,
    80,    80,    80,    80,    80,    80,    72,    72,    72,    72,
    56,    56,    56,    56,    38,    91,   110,   110,   110,   110,
   110,   110,   110,   110,   110,   110,     2,     2,     2,     2,
    92,     2,     2,     2,     2,     2,     2,     2,    39,     2,
     2,   107,     3,     2,     2,     2,     2,     0,     0,     0,
     0,   112,     0,     0,     0,     0,     0,     0,     0,   115,
     0,     0,     1,   121,     0,     0,     0,     0,    52,    52,
    52,    52,    73,    73,    73,    73,    51,    51,    51,    51,
    78 ]

racc_action_pointer = [
   179,   202,   158,   175,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,     1,    93,    92,    87,    43,    45,    86,    46,
    65,    74,    70,    69,    64,     5,     4,   121,   147,   171,
   104,   nil,   nil,     3,    -1,   nil,   nil,   nil,   nil,    50,
     0,   213,   205,   108,   nil,   nil,   147,    95,    84,    71,
    75,    32,    57,    42,   nil,    66,     2,    30,    48,    72,
    34,   nil,   143,   209,    -2,    90,   nil,    80,   191,   nil,
   103,    87,   nil,    63,    49,   nil,   nil,   nil,   108,     2,
   nil,   143,   158,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,   nil,     3,   nil,   151,   nil,   nil,
   123,   nil,   148,   nil,   nil,   156,   nil,   nil,   nil,   nil,
    77,   160,    -3,   nil,   nil ]

racc_action_default = [
   -74,   -74,    -1,   -74,    -4,    -5,    -6,    -7,    -8,    -9,
   -10,   -11,   -12,   -13,   -14,   -15,   -16,   -17,   -18,   -20,
   -21,   -22,   -74,   -74,   -74,   -74,   -74,   -74,   -74,   -74,
   -74,   -74,   -74,   -74,   -74,   -74,   -74,   -74,   -74,    -2,
   -23,   -67,   -68,   -74,   -74,   -71,   -72,   -73,   -24,   -74,
   -74,   -27,   -28,   -74,   -31,   -32,   -33,   -74,   -74,   -74,
   -74,   -74,   -74,   -74,   125,    -3,   -74,   -74,   -74,   -74,
   -74,   -70,   -25,   -26,   -29,   -74,   -35,   -74,   -74,   -38,
   -74,   -74,   -40,   -63,   -64,   -65,   -66,   -69,   -30,   -74,
   -44,   -74,   -74,   -48,   -49,   -50,   -51,   -52,   -53,   -54,
   -55,   -56,   -57,   -36,   -37,   -74,   -42,   -74,   -39,   -34,
   -74,   -46,   -58,   -59,   -47,   -74,   -41,   -43,   -45,   -60,
   -74,   -74,   -74,   -61,   -62 ]

racc_goto_table = [
    40,     3,   111,    38,    51,    52,    79,   119,    82,    56,
   121,   118,    89,     2,   114,   113,   123,   105,     1,   nil,
   nil,    70,    71,   104,   nil,   nil,   108,    72,    73,   nil,
   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,    83,    84,    85,    86,   nil,   nil,
   nil,   nil,    88,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   122 ]

racc_goto_check = [
    20,     3,    25,     3,    20,    20,    22,    28,    22,    20,
    28,    23,    21,     2,    26,    27,    28,    21,     1,   nil,
   nil,    20,    20,    22,   nil,   nil,    22,    20,    20,   nil,
   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,    20,    20,    20,    20,   nil,   nil,
   nil,   nil,    20,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,    20 ]

racc_goto_pointer = [
   nil,    18,    13,     1,   nil,   nil,   nil,   nil,   nil,   nil,
   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,   nil,
   -22,   -63,   -55,   -99,   nil,   -89,   -78,   -76,  -105,   nil,
   nil ]

racc_goto_default = [
   nil,   nil,   nil,   nil,    19,    20,     6,     7,     8,     9,
    10,    11,    12,    13,    14,    15,    16,    17,    18,    21,
   nil,   nil,   nil,    90,    91,   nil,   nil,   nil,   nil,    41,
    42 ]

racc_reduce_table = [
  0, 0, :racc_error,
  1, 47, :_reduce_none,
  2, 48, :_reduce_none,
  3, 48, :_reduce_none,
  1, 50, :_reduce_4,
  1, 51, :_reduce_5,
  1, 49, :_reduce_none,
  1, 49, :_reduce_none,
  1, 49, :_reduce_none,
  1, 49, :_reduce_none,
  1, 49, :_reduce_none,
  1, 49, :_reduce_none,
  1, 49, :_reduce_none,
  1, 49, :_reduce_none,
  1, 49, :_reduce_none,
  1, 49, :_reduce_none,
  1, 49, :_reduce_none,
  1, 49, :_reduce_none,
  1, 49, :_reduce_none,
  2, 49, :_reduce_none,
  1, 49, :_reduce_none,
  1, 49, :_reduce_none,
  1, 49, :_reduce_none,
  2, 53, :_reduce_23,
  2, 54, :_reduce_24,
  3, 56, :_reduce_25,
  3, 57, :_reduce_26,
  2, 58, :_reduce_27,
  2, 65, :_reduce_28,
  3, 55, :_reduce_29,
  4, 55, :_reduce_30,
  2, 59, :_reduce_31,
  2, 60, :_reduce_32,
  2, 61, :_reduce_33,
  5, 62, :_reduce_34,
  3, 64, :_reduce_35,
  4, 63, :_reduce_36,
  4, 52, :_reduce_37,
  3, 52, :_reduce_38,
  4, 52, :_reduce_39,
  3, 52, :_reduce_40,
  3, 68, :_reduce_41,
  2, 68, :_reduce_42,
  3, 68, :_reduce_43,
  1, 67, :_reduce_44,
  3, 67, :_reduce_45,
  2, 69, :_reduce_46,
  2, 69, :_reduce_47,
  1, 70, :_reduce_48,
  1, 70, :_reduce_49,
  1, 70, :_reduce_50,
  1, 70, :_reduce_51,
  1, 70, :_reduce_52,
  1, 70, :_reduce_53,
  1, 70, :_reduce_54,
  1, 70, :_reduce_55,
  1, 70, :_reduce_56,
  1, 70, :_reduce_57,
  1, 71, :_reduce_58,
  1, 71, :_reduce_59,
  2, 73, :_reduce_60,
  3, 72, :_reduce_61,
  3, 74, :_reduce_62,
  3, 66, :_reduce_63,
  3, 66, :_reduce_64,
  3, 66, :_reduce_65,
  3, 66, :_reduce_66,
  1, 66, :_reduce_none,
  1, 75, :_reduce_none,
  3, 75, :_reduce_69,
  2, 75, :_reduce_70,
  1, 76, :_reduce_71,
  1, 76, :_reduce_72,
  1, 76, :_reduce_73 ]

racc_reduce_n = 74

racc_shift_n = 125

racc_token_table = {
  false => 0,
  :error => 1,
  :UMINUS => 2,
  "*" => 3,
  "/" => 4,
  "+" => 5,
  "-" => 6,
  :EOL => 7,
  :SH => 8,
  :CH => 9,
  :WORKBUFSIZE => 10,
  :PROTOCOLNAME => 11,
  :IDENT => 12,
  :DEFINE => 13,
  :STATIC => 14,
  :IDMAX => 15,
  :CLICLASSMODE => 16,
  :ENUM => 17,
  :SERVERCONNECTION => 18,
  :PROTOCOLID => 19,
  :NUMBER => 20,
  :VERSION => 21,
  :STRUCT => 22,
  "{" => 23,
  "}" => 24,
  :IFDEF => 25,
  :RECVLIMIT => 26,
  :S2C => 27,
  :C2S => 28,
  "(" => 29,
  ")" => 30,
  :VOID => 31,
  "," => 32,
  :STRINGARRAY => 33,
  :INT => 34,
  :CHAR => 35,
  :SHORT => 36,
  :INT64 => 37,
  :UINT => 38,
  :USHORT => 39,
  :UCHAR => 40,
  :STRING => 41,
  :FLOAT => 42,
  "[" => 43,
  "]" => 44,
  :QSTR => 45 }

racc_nt_base = 46

racc_use_result_var = true

Racc_arg = [
  racc_action_table,
  racc_action_check,
  racc_action_default,
  racc_action_pointer,
  racc_goto_table,
  racc_goto_check,
  racc_goto_default,
  racc_goto_pointer,
  racc_nt_base,
  racc_reduce_table,
  racc_token_table,
  racc_shift_n,
  racc_reduce_n,
  racc_use_result_var ]

Racc_token_to_s_table = [
  "$end",
  "error",
  "UMINUS",
  "\"*\"",
  "\"/\"",
  "\"+\"",
  "\"-\"",
  "EOL",
  "SH",
  "CH",
  "WORKBUFSIZE",
  "PROTOCOLNAME",
  "IDENT",
  "DEFINE",
  "STATIC",
  "IDMAX",
  "CLICLASSMODE",
  "ENUM",
  "SERVERCONNECTION",
  "PROTOCOLID",
  "NUMBER",
  "VERSION",
  "STRUCT",
  "\"{\"",
  "\"}\"",
  "IFDEF",
  "RECVLIMIT",
  "S2C",
  "C2S",
  "\"(\"",
  "\")\"",
  "VOID",
  "\",\"",
  "STRINGARRAY",
  "INT",
  "CHAR",
  "SHORT",
  "INT64",
  "UINT",
  "USHORT",
  "UCHAR",
  "STRING",
  "FLOAT",
  "\"[\"",
  "\"]\"",
  "QSTR",
  "$start",
  "prog",
  "directive_list",
  "directive",
  "sh",
  "ch",
  "defun",
  "workbufsize",
  "protocolname",
  "enum",
  "define",
  "static",
  "idmax",
  "serverconnection",
  "protocolid",
  "version",
  "struct",
  "recvlimit",
  "ifdef",
  "cliclassmode",
  "expr",
  "name_list",
  "param",
  "arg",
  "type",
  "variable",
  "array_2d",
  "array",
  "element",
  "primary",
  "realprim" ]

Racc_debug_parser = false

##### State transition tables end #####

# reduce 0 omitted

# reduce 1 omitted

# reduce 2 omitted

# reduce 3 omitted

def _reduce_4(val, _values, result)
  @sh.push( val[0][1] )

    result
end

def _reduce_5(val, _values, result)
  @ch.push( val[0][1] )

    result
end

# reduce 6 omitted

# reduce 7 omitted

# reduce 8 omitted

# reduce 9 omitted

# reduce 10 omitted

# reduce 11 omitted

# reduce 12 omitted

# reduce 13 omitted

# reduce 14 omitted

# reduce 15 omitted

# reduce 16 omitted

# reduce 17 omitted

# reduce 18 omitted

# reduce 19 omitted

# reduce 20 omitted

# reduce 21 omitted

# reduce 22 omitted

def _reduce_23(val, _values, result)
 @workbufsize = val[1]
    result
end

def _reduce_24(val, _values, result)
    if @protocolname == "defaultproto"
      @protocolname = val[1][1].to_s 
    end
  
    result
end

def _reduce_25(val, _values, result)
  add_define( val[0][2], val[0][0], val[1][1], val[2])

    result
end

def _reduce_26(val, _values, result)
 add_static( val[0][2], val[0][0], val[1][1], val[2]) 
    result
end

def _reduce_27(val, _values, result)
 set_idmax( val[1]) 
    result
end

def _reduce_28(val, _values, result)
    @cliclassmode = val[1].to_i
  
    result
end

def _reduce_29(val, _values, result)
    add_enum( val[0][2], val[0][0], val[1][1], val[2][1], nil)
  
    result
end

def _reduce_30(val, _values, result)
    add_enum( val[0][2], val[0][0], val[1][1], val[2][1], val[3])
  
    result
end

def _reduce_31(val, _values, result)
    if val[1][1] != :conn and val[1][1] != :circ and val[1][1] != :vpr_circ then
      raise GenError, "#{val[1][2]}:#{val[1][0]}: serverconnection has to be 'conn' or 'circ' or 'vpr_circ'."
    end
    if val[1][1] == :vpr_circ then
      @vpr = true
      @serverconnection = :circ
    else
      @serverconnection = val[1][1]
    end
  
    result
end

def _reduce_32(val, _values, result)
    id = val[1][1].to_i
    if id <= 0 or id > 255 then
      raise GenError, "#{val[1][2]}:#{val[1][0]}: you should set protocol id from 1 to 255 [#{id}]\n"
    end
    @protocolid = val[1][1]
  
    result
end

def _reduce_33(val, _values, result)
  if @version == -1
    @version = val[1]
   end

    result
end

def _reduce_34(val, _values, result)
    str = @protocolname + "_" + val[1][1].to_s
    @structname.push( str )
    @struct[str] = val[3]
  
    result
end

def _reduce_35(val, _values, result)
    @ifdef["#{val[2][1]}"]=val[1][1]
  
    result
end

def _reduce_36(val, _values, result)
    @recvlimit["#{val[1][1]}.limit"]=val[2][1]
    @recvlimit["#{val[1][1]}.time"]=val[3][1]
  
    result
end

def _reduce_37(val, _values, result)
    add_proto( @s2c, val[1][2], val[1][0], val[1][1], val[2][1], val[3])
    @currentid = val[1][1]
  
    result
end

def _reduce_38(val, _values, result)
    @currentid += 1
    add_proto( @s2c, val[1][2], val[1][0], @currentid, val[1][1], val[2])
  
    result
end

def _reduce_39(val, _values, result)
    add_proto( @c2s, val[1][2], val[1][0], val[1][1], val[2][1], val[3])
    @currentid = val[1][1]
  
    result
end

def _reduce_40(val, _values, result)
    @currentid += 1
    add_proto( @c2s, val[1][2], val[1][0], @currentid, val[1][1], val[2])
  
    result
end

def _reduce_41(val, _values, result)
 result = val[1] 
    result
end

def _reduce_42(val, _values, result)
 result = [] 
    result
end

def _reduce_43(val, _values, result)
 result = [] 
    result
end

def _reduce_44(val, _values, result)
 result = [ val[0]] 
    result
end

def _reduce_45(val, _values, result)
 result.push val[2] 
    result
end

def _reduce_46(val, _values, result)
    # パラメータが配列の時
    if val[1].is_a? Array then
      result = { 'type' => :array, 'vartype' => val[0], 'name' => val[1][0], 'value' => val[1][1]}
    else
      result = { 'type' => :single, 'vartype' => val[0], 'name' => val[1], 'value' => [nil,nil]}
    end
  
    result
end

def _reduce_47(val, _values, result)
    result = { 'type' => :array, 'vartype' => val[0][1], 'name' => val[1][0], 'value' => val[1][1]}
  
    result
end

def _reduce_48(val, _values, result)
 result = val[0][1] 
    result
end

def _reduce_49(val, _values, result)
 result = val[0][1] 
    result
end

def _reduce_50(val, _values, result)
 result = val[0][1] 
    result
end

def _reduce_51(val, _values, result)
 result = val[0][1] 
    result
end

def _reduce_52(val, _values, result)
 result = val[0][1] 
    result
end

def _reduce_53(val, _values, result)
 result = val[0][1] 
    result
end

def _reduce_54(val, _values, result)
 result = val[0][1] 
    result
end

def _reduce_55(val, _values, result)
 result = val[0][1] 
    result
end

def _reduce_56(val, _values, result)
 result = val[0][1] 
    result
end

def _reduce_57(val, _values, result)
 result = val[0][1] 
    result
end

def _reduce_58(val, _values, result)
 result = val[0][1] 
    result
end

def _reduce_59(val, _values, result)
 result = val[0] 
    result
end

def _reduce_60(val, _values, result)
 result = [val[0][1], [val[1]]] 
    result
end

def _reduce_61(val, _values, result)
 result = [val[0][1], [val[1], val[2]]] 
    result
end

def _reduce_62(val, _values, result)
 result = val[1] 
    result
end

def _reduce_63(val, _values, result)
 result = val[0] + val[2] 
    result
end

def _reduce_64(val, _values, result)
 result = val[0] - val[2] 
    result
end

def _reduce_65(val, _values, result)
 result = val[0] * val[2] 
    result
end

def _reduce_66(val, _values, result)
 result = val[0] / val[2] 
    result
end

# reduce 67 omitted

# reduce 68 omitted

def _reduce_69(val, _values, result)
 result = val[1] 
    result
end

def _reduce_70(val, _values, result)
 result = -val[1] 
    result
end

def _reduce_71(val, _values, result)
 result = get_variables_value( val[0][2], val[0][0], val[0][1]) 
    result
end

def _reduce_72(val, _values, result)
 result = val[0][1] 
    result
end

def _reduce_73(val, _values, result)
 result = val[0][1] 
    result
end

def _reduce_none(val, _values, result)
  val[0]
end

end   # class Gen

#
# gen_maker.rb
#
#
# Copyright (C) 2000-2005 Community Engine Inc. All rights reserved.
# For more information, please visit our website at www.ce-lab.net.
#


#
# gen から出力されるソースを作る抽象クラス
# 
module Genmaker
  def create( source, gen, sv = true, cli = true, testsv = false, testcli = false, testrecvcli = false, use_const = true )
    case source
    when "rb"
      Genmaker_rb.new( gen, sv, cli, testsv, testcli, testrecvcli )
    when "c"
      Genmaker_c.new( gen, sv, cli, testsv, testcli, testrecvcli, use_const )
    when "cpp"
      Genmaker_cpp.new( gen, sv, cli, testsv, testcli, testrecvcli, use_const )
    else
      nil
    end
  end
  module_function :create
  class Abstract
    ToolName = "gen.rb CommunityEngine Inc. 2000-2005"
    def initialize( gen, sv, cli, testsv, testcli, testrecvcli )
      @gen = gen
      @sv = sv
      @cli = cli
      @testsv = testsv
      @testcli = testcli
      @testrecvcli = testrecvcli
      @server_cnt_protodecl = []
      @client_cnt_protodecl = []
      @server_cntfuncdef = []
      @client_cntfuncdef = []
      @server_cntvardef = []
      @server_connvarinit = []
      @server_connvardef = []
      @client_cntvardef = []
      @server_protodecl = []
      @client_protodecl = []
      @server_sendfuncdef = []
      @client_sendfuncdef = []
      @server_recvcasedef = []
      @client_recvcasedef = []
      @server_samplerecvfuncdef = []
      @client_samplerecvfuncdef = []
      @server_samplesendfuncdef = []
      @client_samplesendfuncdef = []
      @client_test_recv = []
      @header_funcenum = ""
      @client_ddvardef=[]
      @server_ddvardef=[]
      @client_ddfuncdef=[]
      @server_ddfuncdef=[]
      @client_ddfuncptype=[]
      @server_ddfuncptype=[]
    end
    # 出力用文字列作成。
    # 実際に作る文字列はサブクラスに任せる。
    def make
      idhash = {}
      @gen.c2s.each do |d|
        funcname = d['funcname']
        argdef = d['args']
        id = d['id']
        @header_funcenum += make_funcenum(funcname,id,"c2s")
        @server_cnt_protodecl.push( make_cnt_ptype( "recv", funcname ) + ";\n")
        @client_cnt_protodecl.push( make_cnt_ptype( "send", funcname ) + ";\n")
        @server_cntfuncdef.push( get_cnt_funcdef( "recv", funcname ))
        @client_cntfuncdef.push( get_cnt_funcdef( "send", funcname ))
        @server_cntvardef.push( get_cnt_vardef( "recv", funcname ))
        @server_connvardef.push( get_conn_vardef( funcname ))
        @server_connvarinit.push( get_conn_varinit( funcname ))
        @client_cntvardef.push( get_cnt_vardef( "send", funcname ))
        @server_protodecl.push( make_ptype( "recv", funcname, argdef) +";\n")
        @client_protodecl.push( make_ptype( "send", funcname, argdef, "conn") +";\n")
        @client_sendfuncdef.push( get_send_funcdef( funcname, argdef, id, 
                                                   "cli_sender", "conn"
                                                   ))
        @server_recvcasedef.push( get_recv_casedef( funcname, argdef, id, false ))
        @server_samplerecvfuncdef.push( get_sample_recv_funcdef( funcname, argdef ))
        @client_samplesendfuncdef.push( get_sample_send_funcdef( funcname, argdef ))
        @server_ddvardef.push(get_dd_vardef("recv",funcname))
        @client_ddvardef.push(get_dd_vardef("send",funcname))
        @server_ddfuncdef.push(get_dd_funcdef("recv",funcname))
        @client_ddfuncdef.push(get_dd_funcdef("send",funcname))
        @server_ddfuncptype.push(get_dd_funcptype("recv",funcname))
        @client_ddfuncptype.push(get_dd_funcptype("send",funcname))
      end

      @client_protodecl.push( "\n\n\n" )
      @server_protodecl.push( "\n\n\n" )

      @gen.s2c.each do |d|
        funcname = d['funcname']
        argdef = d['args']
        id = d['id']
        @header_funcenum += make_funcenum(funcname,id,"s2c")
        @server_cnt_protodecl.push( make_cnt_ptype( "send", funcname ) + ";\n")
        @client_cnt_protodecl.push( make_cnt_ptype( "recv", funcname ) + ";\n")
        @server_cntfuncdef.push( get_cnt_funcdef( "send", funcname ))
        @client_cntfuncdef.push( get_cnt_funcdef( "recv", funcname ))
        @server_cntvardef.push( get_cnt_vardef( "send", funcname ))
        @client_cntvardef.push( get_cnt_vardef( "recv", funcname ))
        @server_protodecl.push( make_ptype( "send", funcname, argdef)+";\n")
        @client_protodecl.push( make_ptype( "recv", funcname, argdef, "conn")+";\n")
        @server_sendfuncdef.push( get_send_funcdef( funcname, argdef, id, 
                                                   "sv_sender"
                                                   ))
        #@client_recvcasedef.push( get_recv_casedef( funcname, argdef, id, "conn" ))
        if @gen.cliclassmode == 0
            @client_recvcasedef.push( get_recv_casedef( funcname, argdef, id, true, "conn" ))
        else
            @client_recvcasedef.push( get_recv_casedef( funcname, argdef, id, false, "conn" ))
        end

        @client_samplerecvfuncdef.push( get_sample_recv_funcdef( funcname, argdef ))
        @server_samplesendfuncdef.push( get_sample_send_funcdef(funcname,argdef))
        @client_test_recv.push( get_recv( funcname, argdef))
        @server_ddvardef.push(get_dd_vardef("send",funcname))
        @client_ddvardef.push(get_dd_vardef("recv",funcname))
        @server_ddfuncdef.push(get_dd_funcdef("send",funcname))
        @client_ddfuncdef.push(get_dd_funcdef("recv",funcname))
        @server_ddfuncptype.push(get_dd_funcptype("send",funcname))
        @client_ddfuncptype.push(get_dd_funcptype("recv",funcname))
      end
      @sv_src = get_server_source
      @cli_src = get_client_source
      @sv_h = get_server_header
      @cli_h = get_client_header
      @sv_test_src = get_server_test_source
      @cli_test_src = get_client_test_source
      @cli_test_recv_src = get_client_test_recv_source
    end
    def save_file
      if @sv then
        if @sv_src != "" then
          name = "#{@gen.protocolname}_sv.#{extention}"
          f = File.open( name, "w")
          f.write( @sv_src)
          f.close
        end
        if @sv_h != "" then
          name = "#{@gen.protocolname}_sv.h"
          f = File.open( name, "w")
          f.write( @sv_h)
          f.close
        end        
      end
      if @cli then
        if @cli_src != "" then
          name = "#{@gen.protocolname}_cli.#{extention}"
          f = File.open( name, "w")
          f.write( @cli_src)
          f.close
        end
        if @cli_h != "" then
          name = "#{@gen.protocolname}_cli.h"
          f = File.open( name, "w")
          f.write( @cli_h)
          f.close
        end
      end
      if @testsv then
        if @sv_test_src != "" then
          name = "#{@gen.protocolname}_test_sv.#{extention}"
          f = File.open( name, "w")
          f.write( @sv_test_src )
          f.close
        end
      end
      if @testcli then
        if @cli_test_src != "" then
          name = "#{@gen.protocolname}_test_cli.#{extention}"
          f = File.open( name, "w")
          f.write( @cli_test_src)
          f.close
        end
      end
      if @testrecvcli then
        if @cli_test_recv_src != "" then
          name = "#{@gen.protocolname}_test_recv_cli.#{extention}"
          f = File.open( name, "w")
          f.write( @cli_test_recv_src)
          f.close
        end
      end
    end
    def extention
      ""
    end
    protected
    def make_funcenum(funcname,id,type)
      ""
    end
    def make_cnt_ptype( action, funcname)
      ""
    end
    def get_dd_vardef( action, msgname)
      ""
    end
    def get_dd_funcptype( action, msgname)
      ""
    end
    def get_dd_funcdef( action, msgname)
      ""
    end
    def get_cnt_funcdef( action, funcname)
    end
    def get_cnt_vardef( action, funcname)
    end
    def get_conn_vardef(funcname)
    end
    def get_conn_varinit(funcname)
    end
    def make_ptype( action, funcname, argdef, con = nil)
    end
    def get_send_funcdef( funcname, argdef, id, sender)
    end
    def get_recv_casedef( funcname, argdef, id, con = nil)
    end
    def get_server_source
      ""
    end
    def get_client_source
      ""
    end
    def get_server_header
      ""
    end
    def get_client_header
      ""
    end
    def get_server_test_source
      ""
    end
    def get_client_test_source
      ""
    end
    def get_client_test_recv_source
      ""
    end
    def get_recv( funcname, argdef)
    end
  end
end

#
# gen_maker_c.rb
#
#
# Copyright (C) 2000-2005 Community Engine Inc. All rights reserved.
# For more information, please visit our website at www.ce-lab.net.
#

# c and cpp のソースを出力する実装のクラス

class Genmaker_c < Genmaker::Abstract
  Command_bits_type = { 1 => "unsigned char", 2 => "unsigned short",4 => "unsigned int" }
  Command_bits_getter = { 1 => "GET_8BIT_INT", 2 => "GET_16BIT_INT",4 => "GET_32BIT_INT"}
#  Command_bits_setter = { 1 =>"SET_8BIT_INT", 2 =>"SET_16BIT_INT", 4 => "SET_32BIT_INT"}
  Command_bits_setter = { 1 =>"_PUSH_I1", 2 =>"_PUSH_I2", 4 => "_PUSH_I4", 8 => "_PUSH_I8" }
  def initialize( gen, sv, cli, testsv, testcli, testrecvcli, use_const )
    super( gen, sv, cli, testsv, testcli, testrecvcli )
    if use_const
      @const_str = 'const'
    else
      @const_str = ''
    end
  end
  def extention
    "c"
  end
  def get_popper(type,vartype,name,num,subnum)
    data = {
      "single.char" => "_POP_I1",
      "single.short" => "_POP_I2",
      "single.int" => "_POP_I4",
      "single.int64" => "_POP_I8",
      "single.uchar" => "_POP_I1",
      "single.ushort" => "_POP_I2",
      "single.uint" => "_POP_I4",
      "single.float" => "_POP_F4",
      "array.char" => "_POP_IA1",
      "array.short" => "_POP_IA2",
      "array.int" => "_POP_IA4",
      "array.int64" => "_POP_IA8",
      "array.uchar" => "_POP_IA1",
      "array.ushort" => "_POP_IA2",
      "array.uint" => "_POP_IA4",
      "array.float" => "_POP_FA4",
      "array.char *" => "_POP_STRA" }
    r = data[ "#{type}.#{vartype}" ]
#    raise "bad type and vartype '#{type}.#{vartype}'" if( r == nil ) 
    if( r == nil ) then
      outwk = ""
      outwk += get_popper_struct( vartype, name, num, 0 )
      return outwk
#      return get_popper_struct( vartype, name )
    end

    if( type == "array" ) then
      if( vartype == "char *" ) then
        return "#{r}(#{name},#{name}_len,#{subnum},#{name}_i,#{name}_p);\n"
      else
        return "#{r}(#{name},#{name}_len);\n"
      end
    else
      return "#{r}(#{name});\n"
    end
  end

  def get_popper_struct( vartype,structname,nummax,nest,out = "",str_add = "" )
    if( @gen.struct["#{@gen.protocolname}_#{vartype}"] == nil )
      vartypewk = vartype
      vartype = vartypewk.upcase
      raise "bad type and vartype #{vartype}" if( @gen.struct["#{@gen.protocolname}_#{vartype}"] == nil )
    end

    data = {
      "single.char"   => "_POP_I1",
      "single.short"  => "_POP_I2",
      "single.int"    => "_POP_I4",
      "single.int64"  => "_POP_I8",
      "single.uchar"  => "_POP_I1",
      "single.ushort" => "_POP_I2",
      "single.uint"   => "_POP_I4",
      "single.float"  => "_POP_F4",
      "array.char"    => "_POP_IA1",
      "array.short"   => "_POP_IA2",
      "array.int"     => "_POP_IA4",
      "array.int64"   => "_POP_IA8",
      "array.uchar"   => "_POP_IA1",
      "array.ushort"  => "_POP_IA2",
      "array.uint"    => "_POP_IA4",
      "array.float"   => "_POP_FA4",
      "array.char *"  => "_POP_STRA",
      "array.stringarray"  => "_POP_STRA",
      "array.string"  => "_POP_IA1" }

    if ( str_add == "" ) then
      str_add = structname
    else
      str_add = "#{str_add}.#{structname}"
    end

    index = "i"
    space1 = "        "
    space2 = "    "
    if( nummax != nil )
      if( nest == 0 )
        out += "int i, j;\n"
        out += "    int lenwk;\n"
      else
        space1 += "    "
        space2 += "    "
        index = "j"
      end
      r = data["single.int"]
      out += "#{space2}#{r}(#{str_add}_len)\n"
      out += "#{space2}for(#{index} = 0; #{index} < #{str_add}_len; #{index}++)\n"
      out += "#{space2}{\n"
    end
    @gen.struct["#{@gen.protocolname}_#{vartype}"].each do |val|

      name = val['name']
      num = val['value'][0]

      r = data["#{val['type']}.#{val['vartype']}"]
      outwk = ""
      if( r == nil )
        str_add = "#{structname}[#{index}]"
        out += get_popper_struct( val['vartype'],name,num,1,outwk,str_add )
	    next
      end

      if( nummax == nil ) then
        if( val['type'] == :array ) then
          if( val['vartype'] == :string ) then
            out += "#{space1}lenwk = #{num};\n"
            out += "#{space1}#{r}(#{str_add}.#{name},lenwk);\n"
          elsif( val['vartype'] == :stringarray ) then
            out += "#{space1}#{r}(#{str_add}.#{name},#{str_add}.#{name}_len,#{val['value'][1]},#{name}_i,#{name}_p);\n"
          else
            out += "#{space1}#{str_add}.#{name}_len = #{num};\n"
            out += "#{space1}#{r}(#{str_add}.#{name},#{str_add}.#{name}_len);\n"
          end
        else
          out += "#{space1}#{r}(#{str_add}.#{name});\n"
        end
      else
        s_part = "#{str_add}[#{index}]"
        if( val['type'] == :array ) then
          if( val['vartype'] == :string ) then
            out += "#{space1}lenwk = #{num};\n"
            out += "#{space1}#{r}(#{s_part}.#{name},lenwk);\n"
          elsif( val['vartype'] == :stringarray ) then
            out += "#{space1}#{r}(#{s_part}.#{name},#{s_part}.#{name}_len,#{val['value'][1]},#{name}_i,#{name}_p);\n"
          else
            out += "#{space1}#{s_part}.#{name}_len = #{num};\n"
            out += "#{space1}#{r}(#{s_part}.#{name},#{s_part}.#{name}_len);\n"
          end
        else
          out += "#{space1}#{r}(#{s_part}.#{name});\n"
        end
      end
    end
    if( nummax != nil )
      out += "#{space2}}\n"
    end
    return out
  end

  def get_struct_length( vartype, len )
    if( @gen.struct["#{@gen.protocolname}_#{vartype}"] == nil )
      vartypewk = vartype
      vartype = vartypewk.upcase
      raise "bad type and vartype #{vartype}" if( @gen.struct["#{@gen.protocolname}_#{vartype}"] == nil )
    end

    datasize = {
      "single.char" => 1,
      "single.short" => 2,
      "single.int" => 4,
      "single.int64" => 8,
      "single.uchar" => 1,
      "single.ushort" => 2,
      "single.uint" => 4,
      "single.float" => 4,
      "array.char" => 1,
      "array.short" => 2,
      "array.int" => 4,
      "array.int64" => 8,
      "array.uint" => 4,
      "array.float" => 4,
      "array.uchar" => 1,
      "array.ushort" => 2,
      "array.char *" => 1 }
    @gen.struct["#{@gen.protocolname}_#{vartype}"].each do |val|
      vtype = val['type']
      vvartype = val['vartype']
      vnum = val['value'][0]
      vsubnum = val['value'][1]
      if( vvartype == :stringarray ) then
        vvartype = "char *"
      elsif( vvartype == :string ) then
        vvartype = "char"
      end
      lenwk = datasize["#{vtype}.#{vvartype}"]
      if( lenwk == nil )
        lenwk = 0
        if( vnum != nil )
          len += get_struct_length( vvartype, lenwk )*vnum
          len += 5
        else
          len += get_struct_length( vvartype, lenwk )
        end
#        next
      else
        if( vnum != nil )
          if( vsubnum != nil )
            len += lenwk*vnum*vsubnum
            len += 5*vnum
          else
            len += lenwk*vnum
            len += 5
          end
        else
          len += lenwk
        end
      end
      if( vvartype == "char" || vvartype == "char *" )
        len += 5
      end
    end
    return len
  end

  def get_pusher(type,vartype,name,num,subnum,outmax)
    data = {
      "single.char" => "_PUSH_I1",
      "single.short" => "_PUSH_I2",
      "single.int" => "_PUSH_I4",
      "single.int64" => "_PUSH_I8",
      "single.uchar" => "_PUSH_I1",
      "single.ushort" => "_PUSH_I2",
      "single.uint" => "_PUSH_I4",
      "single.float" => "_PUSH_F4",
      "array.char" => "_PUSH_IA1",
      "array.short" => "_PUSH_IA2",
      "array.int" => "_PUSH_IA4",
      "array.int64" => "_PUSH_IA8",
      "array.uint" => "_PUSH_IA4",
      "array.float" => "_PUSH_FA4",
      "array.uchar" => "_PUSH_IA1",
      "array.ushort" => "_PUSH_IA2",
      "array.char *" => "_PUSH_STRA" }
    r = data["#{type}.#{vartype}" ]
#    raise "bad type and vartype '#{type}.#{vartype}'" if( r == nil ) 
    if( r == nil ) then
      outwk = ""
      outwk += get_pusher_struct( vartype,name,outmax,num,0 )
      return outwk
#     return get_pusher_struct( vartype, name, outmax )
    end

    if( type == "array" ) then
      if( vartype == "char *" )then
        return "#{r}(#{name},#{name}_len,#{num},#{outmax},#{subnum});\n"
      else
        return "#{r}(#{name},#{name}_len,#{num},#{outmax});\n"
      end
    else
      return "#{r}(#{name},#{outmax});\n"
    end
  end

  def get_pusher_struct( vartype,structname,outmax,nummax,nest,out = "",str_add = "" )
    if( @gen.struct["#{@gen.protocolname}_#{vartype}"] == nil )
      vartypewk = vartype.to_s
      vartype = vartypewk.upcase
      raise "bad type and vartype #{vartype}" if( @gen.struct["#{@gen.protocolname}_#{vartype}"] == nil )
    end

    data = {
      "single.char"   => "_PUSH_I1",
      "single.short"  => "_PUSH_I2",
      "single.int"    => "_PUSH_I4",
      "single.int64"  => "_PUSH_I8",
      "single.uchar"  => "_PUSH_I1",
      "single.ushort" => "_PUSH_I2",
      "single.uint"   => "_PUSH_I4",
      "single.float"  => "_PUSH_F4",
      "array.char"    => "_PUSH_IA1",
      "array.short"   => "_PUSH_IA2",
      "array.int"     => "_PUSH_IA4",
      "array.int64"   => "_PUSH_IA8",
      "array.uchar"   => "_PUSH_IA1",
      "array.ushort"  => "_PUSH_IA2",
      "array.uint"    => "_PUSH_IA4",
      "array.float"   => "_PUSH_FA4",
      "array.char *"  => "_PUSH_STRA",
      "array.stringarray"  => "_PUSH_STRA",
      "array.string"  => "_PUSH_IA1" }

    if( str_add == "" ) then
      str_add = structname
    else
      str_add = "#{str_add}.#{structname}"
    end

    index = "i"
    space1 = "     "
    space2 = "  "
    if( nummax != nil ) then
      r = data["single.int"]
      if( nest == 0 )
        out += "int i, j;\n"
      else
        index = "j"
        space1 += "   "
        space2 += "   "
      end
      out += "#{space2}#{r}(#{str_add}_len,#{outmax})\n"
      out += "#{space2}for(#{index} = 0; #{index} < #{str_add}_len; #{index}++)\n"
      out += "#{space2}{\n"
    end
    @gen.struct["#{@gen.protocolname}_#{vartype}"].each do |val|
      name = val['name']
      num  = val['value'][0]

      r = data["#{val['type']}.#{val['vartype']}"]
      outwk = ""
      if( r == nil ) then
        str_add = "#{structname}[#{index}]"
        out += get_pusher_struct( val['vartype'],name,outmax,num,1,outwk,str_add )
	    next
      end

      if( nummax == nil ) then
        if( val['type'] == :array ) then
          if( val['vartype'] == :stringarray ) then
            out += "#{space1}#{r}(#{str_add}.#{name},#{str_add}.#{name}_len,#{num},#{outmax},#{val['value'][1]});\n"
          elsif( val['vartype'] == :string ) then
            out += "#{space1}#{r}(#{str_add}.#{name},strlen(#{str_add}.#{name})+1,#{num}+1,#{outmax});\n"
          else
            out += "#{space1}#{r}(#{str_add}.#{name},#{str_add}.#{name}_len,#{num},#{outmax});\n"
          end
        else
          if( val['vartype'] == :string ) then
            out += "#{space1}#{r}(#{str_add}.#{name},strlen(#{str_add}.#{name})+1,#{num}+1,#{outmax});\n"
          else
            out += "#{space1}#{r}(#{str_add}.#{name},#{outmax});\n"
          end
        end
      else
        s_part = "#{str_add}[#{index}]"
        if( val['type'] == :array ) then
          if( val['vartype'] == :stringarray ) then
            out += "#{space1}#{r}(#{s_part}.#{name},#{s_part}.#{name}_len,#{num},#{outmax},#{val['value'][1]});\n"
          elsif( val['vartype'] == :string ) then
            out += "#{space1}#{r}(#{s_part}.#{name},strlen(#{s_part}.#{name})+1,#{num}+1,#{outmax});\n"
          else
            out += "#{space1}#{r}(#{s_part}.#{name},#{s_part}.#{name}_len,#{num},#{outmax});\n"
          end
        else
          if( val['vartype'] == :string ) then
            out += "#{space1}#{r}(#{s_part}.#{name},strlen(#{s_part}.#{name})+1,#{num}+1,#{outmax});\n"
          else
            out += "#{space1}#{r}(#{s_part}.#{name},#{outmax});\n"
          end
        end
      end
    end
    if( nummax != nil ) then
      out += "#{space2}}\n"
    end
    return out
  end

  # C関数のプロトタイプを作る
  # ()の中はコンマでくぎった識別子定義の列である。
  # 識別子定義は、 TYPE NAME  または TYPE NAME [ NUM ] である。
  # Syntax error の場合は raiseする
  # Hashをつくって配列に入れる。
  # pname : プロトコル名
  # action: send/recv
  # iovar : circ_t または conn_t
  # argdef : parse_arglist のかえりち
  def make_ptype( action, name, argdef, con = nil)
    svcon = nil
    if con then
      svcon = con
    else
      svcon = @gen.serverconnection
    end
    if argdef.size == 0 then
      return "int #{@gen.protocolname}_#{name.to_s.gsub(/^.*?((->)|(\.))/, "")}_#{action}( #{svcon}_t _c )"
    else
      out = "int #{@gen.protocolname}_#{name.to_s.gsub(/^.*?((->)|(\.))/, "")}_#{action}( #{svcon}_t _c, "
      append = []

	not_struct = [ "char", "short", "int", "int64", "uchar", "ushort", "uint", "float", "string", "stringarray" ]

      argdef.each{ |i|

        if ( not_struct.index( i["vartype"].to_s ) == nil ) then
          usetype = shorttype2longtype( i["vartype"].to_s )
          if i["type"] == :single
            append.push( "#{@gen.protocolname}_#{usetype} #{i["name"]}" )
          else
            append.push( "#{@gen.protocolname}_#{usetype} *#{i["name"]}, "+
                           "int #{i["name"]}_len" )
          end
        elsif i["type"] == :single then
          usetype = i["vartype"].to_s
          usetype = shorttype2longtype(usetype)
          append.push( "#{usetype} #{i["name"]}" )
        else
          if i["vartype"] == :string then
            append.push( "#{@const_str} char *#{i["name"]}" )
          elsif i["vartype"] == :stringarray then
            append.push( "#{@const_str} char * #{@const_str} *#{i["name"]}, " +
                           "int #{i["name"]}_len" )
          else
            usetype = i["vartype"].to_s
            usetype = shorttype2longtype(usetype)
            append.push( "#{@const_str} #{usetype} *#{i["name"]}, " +
                           "int #{i["name"]}_len" )
          end
        end
      }
      return out + append.join(", ") + " )"
    end
  end

  #受信回数をカウントするための変数初期化
  def get_conn_varinit( msgname)
    limit="#{msgname}.limit"
    time="#{msgname}.time"
    if @gen.recvlimit[limit] &&  @gen.recvlimit[time]
      return "  #{@gen.protocolname}_t_#{msgname}[index].count=0;\n  #{@gen.protocolname}_t_#{msgname}[index].next=next;\n"
    else
      return ""
    end
  end

  #受信回数をカウントするための変数定義
  def get_conn_vardef( msgname)
    limit="#{msgname}.limit"
    time="#{msgname}.time"
    if @gen.recvlimit[limit] &&  @gen.recvlimit[time]
      return "static #{@gen.protocolname}_t #{@gen.protocolname}_t_#{msgname}[#{@gen.protocolname.upcase}_MAX_CONNECTION];\n"
    else
      return ""
    end
  end

  # DebugDisable変数出力
  def get_dd_vardef( action, msgname)
    return "static int #{@gen.protocolname}_#{msgname.to_s().gsub(/^.*?((\.)|(->))/,"")}_#{action}_debugout = 1;\n"
  end

  def get_dd_funcptype( action, msgname)
    return "void #{@gen.protocolname}_#{msgname.to_s().gsub(/^.*?((\.)|(->))/,"")}_#{action}_debugprint(int on_off);\n"
  end
  
  def get_dd_funcdef( action, msgname)
    out="void #{@gen.protocolname}_#{msgname.to_s().gsub(/^.*?((\.)|(->))/,"")}_#{action}_debugprint(int on_off)\n"
    out+="{\n  #{@gen.protocolname}_#{msgname.to_s().gsub(/^.*?((\.)|(->))/,"")}_#{action}_debugout=on_off;\n}\n"
    return out
  end

  # 数えるための変数出力
  def get_cnt_vardef( action, msgname)
    return "static double #{@gen.protocolname}_#{msgname.to_s.gsub(/^.*?((->)|(\.))/, "")}_#{action}_counter = 0;\n"
  end

  # 数えるための関数出力
  def get_cnt_funcdef( action, msgname )
    pt = make_cnt_ptype( action, msgname)
    out = "#{pt}\n"
    out+= "{\n"
    out+= "  return #{@gen.protocolname}_#{msgname.to_s.gsub(/^.*?((->)|(\.))/, "")}_#{action}_counter;\n"
    out+= "}\n"
  end

  # 回数カウント用の関数のプロトタイプを作る
  def make_cnt_ptype( action, name)
    return "double #{@gen.protocolname}_get_#{name.to_s.gsub(/^.*?((->)|(\.))/, "")}_#{action}_count( void )"
  end
  
  # C言語の送信用関数を出力する。
  # iovar: conn_t or circ_t
  # worksize: ワークバッファのサイズ(設定ファイルからよむ)
  # id : コマンドID
  def get_send_funcdef( name, argdef, id, sender, con = nil)
    svcon = nil
    if con then
      svcon = con
    else
      svcon = @gen.serverconnection
    end
    pr = make_ptype( "send", name, argdef, svcon)

    datasize = {
      "single.char" => 1,
      "single.short" => 2,
      "single.int" => 4,
      "single.int64" => 8,
      "single.uchar" => 1,
      "single.ushort" => 2,
      "single.uint" => 4,
      "single.float" => 4,
      "array.char" => 1,
      "array.short" => 2,
      "array.int" => 4,
      "array.int64" => 8,
      "array.uint" => 4,
      "array.float" => 4,
      "array.uchar" => 1,
      "array.ushort" => 2,
      "array.char *" => 1 }
    pushcode = ""
    format = ""
    pargs = ""
    str_stringtype = "";
    strwk = ""
    strmake = ""
    argsize=@gen.commandbits
    argdef.each{ |i|
      vtype = i["type"].to_s
      vnum = i["value"][0]
      vsubnum = i["value"][1]
      vname = i["name"].to_s

      if i['vartype'] == :string then
          vvartype = "char"
          str_stringtype += "  int #{vname}_len = strlen( #{vname} ) + 1;\n"
      elsif i['vartype'] == :stringarray then
          vvartype = "char *"
      else
          vvartype = i['vartype'].to_s
      end
      vvartype.downcase!

      pushcode += "  " + get_pusher( vtype,
                                    vvartype,vname,vnum,vsubnum,
                                    "sizeof(_work)" )

	# 構造体の場合
      if datasize["#{vtype}.#{vvartype}"] == nil then
        argsizewk = 0
        if vnum == nil then
          argsize += get_struct_length( "#{vvartype}", argsizewk )
        else
          argsize += get_struct_length( "#{vvartype}", argsizewk )*vnum
        end
	# debug_print atari ha source minaoshi de tewoiretai
#          strwk += "    struct #{vvartype} _#{vname}wk;\n";
#          format += ", #{vname}=%d"
#          pargs += ", #{vname}"
      elsif vtype == "single"
        if vvartype == "int64"
          format += ", #{vname}=%lld"
        elsif vvartype == "float"
          format += ", #{vname}=%g"
        else
          format += ", #{vname}=%d"
        end
        pargs += ", #{vname}"
        argsize += datasize["#{vtype}.#{vvartype}" ]
      else
        if vvartype == "char"
          format += ", #{vname}[%d]='%s'"
          pargs += ", #{vname}_len, _#{vname}wk"
          strwk += "    char _#{vname}wk[#{vnum.to_i + 1}];\n";
          strmake += "    _make_debug_print_str( _#{vname}wk, #{vnum.to_i + 1}, #{vname}, #{vname}_len);\n"
        else
          format += ", #{vname}[%d]"
          pargs += ", #{vname}_len"
        end
        if vsubnum
          argsize += datasize["#{vtype}.#{vvartype}" ]*vnum*vsubnum
          argsize += 5*vnum
        else
          argsize += datasize["#{vtype}.#{vvartype}" ]*vnum
          argsize += 5
        end
      end

    }
    commandbitssetter = Command_bits_setter[@gen.commandbits]
    out = "/****/\n"
    out+= "#{pr}\n"
    out+= "{\n"
    out+= "  /* Make bin_info array */\n"
    out+= "  char _work[#{argsize}];\n"
    out+= "  int _ofs = 0;\n"
    out+= str_stringtype
    out+= "  #{@gen.protocolname}_#{name.to_s.gsub(/^.*?((->)|(\.))/, "")}_send_counter += 1;\n"
    
    if con and @gen.serverconnection == :circ and @gen.vpr then
      out += "  _PUSH_I1( #{@gen.protocolid}, sizeof(_work));\n"
    end   
#    out+= "  #{commandbitssetter}(_work, #{id} );\n"
    ft=""
    if con
      ft="c2s"
    else
      ft="s2c"
    end
    
    edef="#{@gen.protocolname}_#{ft}_#{name.to_s.gsub(/^.*?((->)|(\.))/, "")}"
    out+= "  #{commandbitssetter}( #{edef.upcase}, sizeof( _work));\n"
    out+= "#{pushcode}\n"
    if @gen.ifdef["#{name}"]
      out+= "#ifdef #{@gen.ifdef["#{name}"]}\n"
    end
    out+= "#ifdef GEN_DEBUG_PRINT\n"
    out+= "  if(#{@gen.protocolname}_#{name.to_s.gsub(/^.*?((->)|(\.))/, "")}_send_debugout)\n"
    out+= "  {\n"
    out+= "    char _addr[256];\n"
    out+= "    int _retsend;\n"
    out+= strwk
    out+= strmake
    out+= "    #{@gen.printf_func}( \"#{@gen.protocolname}_#{name.to_s.gsub(/^.*?((->)|(\.))/, "")}_send( [%s]#{format} )\\n\" , vce_#{svcon}_get_remote_addr_string( _c, _addr, sizeof(_addr) ) #{pargs} );\n"
    out+= "    _retsend=#{@gen.protocolname}_#{sender}( _c, _work, _ofs);\n"
    out+= "    if(_retsend<0){\n"
    out+= "      vce_errout(\"protocol error : #{@gen.protocolname}_#{name.to_s.gsub(/^.*?((->)|(\.))/, "")}_send code : %d\\n\",_retsend);\n"
    out+= "    }\n"
    out+= "    return _retsend;\n"
    out+= "  }\n"
    out+= "  else\n"
    out+= "    return #{@gen.protocolname}_#{sender}( _c, _work, _ofs);\n"
    out+= "#else\n"
    out+= "  return #{@gen.protocolname}_#{sender}( _c, _work, _ofs);\n"
    out+= "#endif\n"
    if @gen.ifdef["#{name}"]
      out+= "#else\n"
      out+= "  return 0;\n"
      out+= "#endif\n"
    end
    out+= "}\n"
    return out
  end

  # 関数のIDにあわせたenumを作る。
  def make_funcenum( funcname, id,type)
    en = "  #{@gen.protocolname}_#{type}_#{funcname.to_s().gsub(/.*?((\.)|(->))/,"")}=#{id},\n"
#    STDERR.print en.upcase
    return en.upcase
  end
  
  #
  # 受信用スイッチのcaseを出力する(C言語用)
  #
  def get_recv_casedef( name, argdef, id, isclient, con=nil)

    name2 = ""

    if isclient == false
        if name.to_s.scan(/\./) != []
            name2 = name.to_s.gsub(/\./, ".#{@gen.protocolname}_")
        elsif name.to_s.scan(/->/) != []
            name2 = name.to_s.gsub(/->/, "->#{@gen.protocolname}_")
        else
            name2 = "#{@gen.protocolname}_#{name}"
    	end
	else
		if name.to_s.scan(/\./) != []
            name2 = name.to_s.gsub(/.*?\./, "#{@gen.protocolname}_")
        elsif name.to_s.scan(/->/) != []
            name2 = name.to_s.gsub(/.*?->/, "#{@gen.protocolname}_")
        else
            name2 = "#{@gen.protocolname}_#{name}"
    	end
	end

    if( argdef.size == 0 ) then
      out = "  case #{id} :\n"
      out+= "#ifdef GEN_DEBUG_PRINT\n"
      out+= "    #{@gen.printf_func}( \"#{name2}_recv()\\n\" );\n"
      out+= "#endif\n"
      out+= "    _ret = #{name2}_recv( _c );\n"
      out+= "    break;\n"
      return out
    end
    if con then
      svcon = con
    else
      svcon = @gen.serverconnection
    end

    datasize = {
      "single.char" => 1,
      "single.short" => 2,
      "single.int" => 4,
      "single.int64" => 8,
      "single.uchar" => 1,
      "single.ushort" => 2,
      "single.uint" => 4,
      "single.float" => 4,
      "array.char" => 1,
      "array.short" => 2,
      "array.int" => 4,
      "array.int64" => 8,
      "array.uint" => 4,
      "array.float" => 4,
      "array.uchar" => 1,
      "array.ushort" => 2,
      "array.char *" => 1 }
    vardecls = ""
    lensets = ""
    args = []
    popcode = ""
    format = ""
    pargs = ""
    strwk = ""
    strmake = ""
    argsize=@gen.commandbits
    argdef.each{ |i|
      vtype = i["type"].to_s
      vnum = i["value"][0]
      vsubnum = i["value"][1]

      if i['vartype'] == :string then
          vvartype = "char"
      elsif i['vartype'] == :stringarray then
          vvartype = "char *"
      else
          vvartype = i["vartype"].to_s
      end
      vvartype.downcase!
      vname = i["name"].to_s

      popcode += "    " + get_popper( vtype,vvartype,vname,vnum,vsubnum )

      if datasize["#{vtype}.#{vvartype}"] == nil then
        # 構造体の場合
        vallist = ""
        if vtype == "array"
          vardecls += "    #{@gen.protocolname}_#{vvartype} #{vname}[#{vnum}];\n"
          vardecls += "    int #{vname}_len = #{vnum};"
          vallist += "#{vname}, #{vname}_len"
        else
          vardecls += "    #{@gen.protocolname}_#{vvartype} #{vname};\n"
          vallist += "#{vname}"
        end
        argsizewk = 0
        if vnum == nil then
          argsize += get_struct_length( "#{vvartype}", argsizewk )
        else
          argsize += get_struct_length( "#{vvartype}", argsizewk )*vnum
          argsize += 5
        end
#        pargs += ",#{vname}"
        args.push(vallist)		# xxx_xxx_recvに追加される

      elsif( vtype == "single" ) then
        if vvartype == "int64" 
          format += ", #{vname}=%lld"
        elsif vvartype == "float"
          format += ", #{vname}=%g"
        else
          format += ", #{vname}=%d"
        end
        argsize += datasize["#{vtype}.#{vvartype}" ]
        vvartype = shorttype2longtype(vvartype)
        vardecls += "    #{vvartype} #{vname};\n"
        pargs += ",#{vname}"
        args.push(vname)
      else
        if( vvartype == "char *") then
          vardecls += "    char #{vname}[#{vnum}][#{vsubnum}];\n"
          vardecls += "    int #{vname}_len = #{vnum};\n"
          vardecls += "    char *#{vname}_p[#{vnum}];\n"
          vardecls += "    int #{vname}_i;\n"
          format += ", #{vname}[%d]"
          pargs += ",#{vname}_len"
          args.push("#{vname}_p,#{vname}_len" )
          argsize += datasize["#{vtype}.#{vvartype}" ] * vnum * vsubnum
          argsize += 5 * vnum
        else
          argsize += datasize["#{vtype}.#{vvartype}" ] * vnum
          argsize += 5
          vvartype = shorttype2longtype(vvartype)
          vardecls += "    #{vvartype} #{vname}[#{vnum}];\n"
          vardecls += "    int #{vname}_len = #{vnum};\n"
          if vvartype == "char"
            format += ", #{vname}[%d]='%s'"
            pargs += ", #{vname}_len, _#{vname}wk"
            strwk += "    char _#{vname}wk[#{vnum.to_i + 1}];\n";
            strmake += "    _make_debug_print_str( _#{vname}wk, #{vnum.to_i + 1}, #{vname}, #{vname}_len);\n"
          else
            format += ", #{vname}[%d]"
            pargs += ", #{vname}_len"
          end

          if i['vartype'] == :string then
            args.push(vname)
          else
            args.push(vname,vname+"_len" )
          end
        end
      end
    }
    
    unless con
#      STDERR.print "server recv protocolsize: #{argsize}\n" 
      if(argsize>@gen.sizeofargs)
        @gen.sizeofargs = argsize
      end
    end
    
    argstr = args.join( ",")
    
    ft=""
    if con
      ft="s2c"
    else
      ft="c2s"
    end

    edef="#{@gen.protocolname}_#{ft}_#{name.to_s().gsub(/.*?((\.)|(->))/,"")}"
    out = "  case  #{edef.upcase} :/* record length : #{argsize} */\n"
    out+= "  {\n"
    out+= "#{vardecls}\n"
    

    # unless con
    #   limit="#{name}.limit"
    #   time="#{name}.time"
    #   if @gen.recvlimit[limit] &&  @gen.recvlimit[time]
    #     counttime=@gen.recvlimit[time] / @gen.recvlimit[limit]
    #     out+="    /* too many call check */\n"
    #     out+="    if(_con_index>=0&&-1==#{@gen.protocolname}_manycall_check(&#{@gen.protocolname}_t_#{name}[_con_index],#{@gen.recvlimit[limit]},#{counttime}000))\n"
    #     out+="    {\n"
    #     out+="      int _eret=#{@gen.protocolname}_toomany_recv_warning(_c,#{id});\n"
    #     out+="#ifdef GEN_DEBUG_PRINT\n"
    #     out+="      vce_errout(\"too many call #{name}\\n\");\n"
    #     out+="#endif\n"
    #     out+="      if(_eret<0)\n"
    #     out+="        return _eret;\n"
    #     out+="    }\n"
    #   end
    # end
    
    unless con
      out+= "    /* protocol length check */\n"
      out+= "    if(#{argsize}<_len){\n"
      out+= "      int _eret=#{@gen.protocolname}_toolong_recv_warning(_c,#{id},_len);\n"
      out+= "#ifdef GEN_DEBUG_LEN_PRINT\n"
      out+= "      vce_errout(\"invalid length : recv%dbytes #{name2}_recv\\n\",_len);\n"
      out+= "#endif\n"
      out+= "      if(_eret<0)\n"
      out+= "        return _eret;\n"
      out+= "    }\n\n"
    end
    
    out+= "#{popcode}\n"
    out+= "    #{@gen.protocolname}_#{name.to_s().gsub(/^.*?((\.)|(->))/,"")}_recv_counter += 1;\n"
    out+= "#ifdef GEN_DEBUG_PRINT\n"
    out+= "    if(#{@gen.protocolname}_#{name.to_s().gsub(/^.*?((\.)|(->))/,"")}_recv_debugout)\n"
    out+= "    {\n"
    out+= "      char _addr[256];\n"
    out+= strwk
    out+= strmake
    out+= "      #{@gen.printf_func}( \"#{name2}_recv( [%s]#{format} )\\n\", vce_#{svcon}_get_remote_addr_string( _c, _addr, sizeof(_addr) ) #{pargs} );\n" 
    out+= "    }\n"
    out+= "#endif\n"

    if @gen.ifdef["#{name}"]
      out+= "#ifdef #{@gen.ifdef["#{name}"]}\n"
    end
    out+= "    _ret = #{name2}_recv( _c, #{argstr});\n"
    if @gen.ifdef["#{name}"]
      out+= "#else\n"
      out+= "    _ret=0;\n"
      out+= "#endif\n"
    end
    out+= "    break;\n"
    out+= "  }\n"
    return out
  end

  # ソースコード全体を出力する
  # con : 'conn' or 'circ'
  # prototypes : C言語的に正しいプロトタイプ宣言のあつまりであること
  def make_define_defs
    uprotoname = @gen.protocolname.upcase
    out = ""
    @gen.define.each do |define, num|
      out += "#undef #{uprotoname}_#{define}\n"
      out += "#define #{uprotoname}_#{define} #{num}\n"
    end
    out+="\n"
    @gen.static.each do |static, num|
      base = @gen.static_base[static].upcase
      out += "#ifndef #{base}_#{static}\n"
      out += "#define #{base}_#{static} #{num}\n"
      out += "#endif\n"
    end
    if @gen.protocolid then
      out += "#undef #{uprotoname}_PROTOCOL_ID\n"
      out += "#define #{uprotoname}_PROTOCOL_ID #{@gen.protocolid}\n"
    end
    out
  end

  # enum の配列から，C言語の typedef つき enum 定義を作りだす．
  # 文字列を返す．
  def make_enum_defs
      enumhash = {}
      enums = []
      out = ""


      @gen.enum.each do |key, e|
          symbol = key.to_s
          enumtype, val,seq = e[0..2]

          o = "_SEQ_#{seq}___ #{@gen.protocolname.upcase}_#{symbol.to_s} = #{val.to_s}\n"
          if enumtype.nil? then
              enums.push( o)
          else
              enumhash[enumtype] = [] if enumhash[enumtype].nil?
              enumhash[enumtype].push( o.gsub( /\n/,"") )
          end
      end
      enumhash.keys.each do |k|
          out += "#ifndef _#{@gen.protocolname.upcase}_#{k}_ENUMDEF_\n"
          out += "#define _#{@gen.protocolname.upcase}_#{k}_ENUMDEF_\n"
          out += "typedef enum {\n"
          enumhash[k].sort.each { |line|
              line.gsub!( /_SEQ_[0-9]+___/,"")
              out += line + ",\n"
          }
          out += "\n} #{@gen.protocolname.upcase}_#{k};\n"
          out += "#endif\n\n"
      end
      enums.each do |d|
          out += d
      end
      return out
  end

  def make_struct_defs
	not_struct = [ "char", "short", "int", "int64", "uchar", "ushort", "uint", "float" ]

	out = ""

#	@gen.struct.each do |key,val|
	@gen.structname.each do |key|
      structname = key
      val = @gen.struct[key.to_s]

      out += "typedef struct _#{structname} {\n"

      val.each do |arg|
		str_len = ""

        vartype = arg['vartype']
        if vartype == :string || vartype == :stringarray then
          vartype = :char
		end
        # 構造体名が検出された場合、@gen.protocolname_を付ける
		if ( not_struct.index( vartype.to_s ) == nil ) then
          out += "#{@gen.protocolname}_"
		end
        vartype = shorttype2longtype( vartype )

        out += "    "
        out += "#{vartype} #{arg['name']}"
        out += "[#{arg['value'][0]}]" if arg['value'][0]
        out += "[#{arg['value'][1]}]" if arg['value'][1]
        out += ";\n"

		if arg['type'] == :array && arg['vartype'] != :string then
#        if arg['type'] == :array then
			out += "    int #{arg['name']}_len;\n"
		end
		if arg['vartype'] == :stringarray then
			out += "    char *#{arg['name']}_p;\n"
			out += "    int #{arg['name']}_i;\n"
		end

          end

          out += "} #{structname};\n"
      end

      return out
  end

  def make_funcenum_defs
    k="FUNCID"
    out = "#ifndef _#{@gen.protocolname.upcase}_#{k}_ENUMDEF_\n"
    out+= "#define _#{@gen.protocolname.upcase}_#{k}_ENUMDEF_\n"
    out+= "typedef enum _#{@gen.protocolname.upcase}_#{k}{\n"
    out+= @header_funcenum
    out+= "  #{@gen.protocolname.upcase}_IDMAX=#{@gen.idmax}\n"
    out+= "} #{@gen.protocolname.upcase}_#{k};\n"
    out+= "#endif\n\n"
    return out
  end

  def get_server_header
    uprotoname = @gen.protocolname.upcase
    defines = make_define_defs
    enums = make_enum_defs
    enums+= make_funcenum_defs
    structs = make_struct_defs
    svcon = @gen.serverconnection.to_s
    out = "/* Generated by #{ToolName} */\n"
    out+= "#ifndef _#{uprotoname}_SV_H_\n"
    out+= "#define _#{uprotoname}_SV_H_\n"
    out+= "#include \"vce.h\"\n"
    out += "#{@gen.sh.join('\n')}\n"
    out += "#{defines}"
    out += "#{enums}"
    out += "#{structs}\n\n"
    out+= "#ifdef __cplusplus\n"
    out+= "extern \"C\" {\n"
    out+= "#endif\n\n"
    out+= "#define #{uprotoname}_MAX_RECV_RECORD_LENGTH #{@gen.sizeofargs}\n"
    out+= "#define #{uprotoname}_MAX_CONNECTION 1024\n"
    out+= "\n"
    out+= "int #{@gen.protocolname}_new(#{svcon}_t c);\n"
    out+= "int #{@gen.protocolname}_del(#{svcon}_t c);\n"
    out+= "int #{@gen.protocolname}_toomany_recv_warning( #{svcon}_t c,int proto_id);\n"
    out+= "int #{@gen.protocolname}_toolong_recv_warning( #{svcon}_t c,int proto_id,int length);\n\n"
    out+= "int #{@gen.protocolname}_sv_pcallback( #{svcon}_t c,char *data,int len );\n"
    out+= "int #{@gen.protocolname}_sv_recv_error_callback( #{svcon}_t c,int e );\n"
    out+= "\n#{@server_cnt_protodecl.join('')}\n"
    out+= "#ifdef GEN_DEBUG_PRINT\n"
    out+= "\n#{@server_ddfuncptype.join('')}\n"
    out+= "#endif\n"
    out+= "\n#{@server_protodecl.join('')}\n"
    out+= "unsigned int #{@gen.protocolname}_sv_get_version( unsigned int *subv );\n"
    out+= "int #{@gen.protocolname}_sv_sender( #{svcon}_t c, char *data, int len );\n"
    out+= "#{svcon}_t  #{@gen.protocolname}_sv_get_current_#{svcon}( void );\n"
    out+= "#ifdef __cplusplus\n"
    out+= "};\n"
    out+= "#endif\n"
    out+= "#endif\n"
    return out
  end
  def get_client_header
    uprotoname = @gen.protocolname.upcase
    defines = make_define_defs
    enums = make_enum_defs
    enums+= make_funcenum_defs
    structs = make_struct_defs
    out = "/* Generated by #{ToolName} */\n"
    out+= "#ifndef _#{uprotoname}_CLI_H_\n"
    out+= "#define _#{uprotoname}_CLI_H_\n"
    out+= "#include \"vce.h\"\n"
    out+= "#{@gen.ch.join('\n')}\n"
    out+= "#ifdef __cplusplus\n"
    out+= "extern \"C\" {\n"
    out+= "#endif\n"
    out+= "#define #{uprotoname}_MAX_CONNECTION 1024\n"
    out+= "\n"
    out += "#{defines}\n\n"
    out += "#{enums}\n\n"
    out += "#{structs}\n\n"
    out+= "int #{@gen.protocolname}_cli_pcallback( conn_t c,char *data,int len );\n"
    out+= "int #{@gen.protocolname}_cli_recv_error_callback( conn_t c, int e );\n"
    out+= "\n#{@client_cnt_protodecl.join('')}\n\n\n"
    out+= "#ifdef GEN_DEBUG_PRINT\n"
    out+= "\n#{@client_ddfuncptype.join('')}\n"
    out+= "#endif\n"
    out+= "\n#{@client_protodecl.join('')}\n\n\n"
    out+= "unsigned int #{@gen.protocolname}_cli_get_version( unsigned int *subv );\n"
    out+= "int #{@gen.protocolname}_cli_sender(conn_t c, char *data, int len );\n"
    out+= "conn_t #{@gen.protocolname}_cli_get_current_conn( void );\n"
    out+= "#ifdef __cplusplus\n"
    out+= "};\n"
    out+= "#endif\n"
    out+= "#endif\n"
    return out
  end

  # cntfuncdefs : 数える用関数の列。
  # sendfuncdefs: 送信用関数の列。C言語的に正しいこと。
  # recvcasedefs : switch の中の case の列。datatop を先頭とすること
  def get_server_source
    uprotoname = @gen.protocolname.upcase
    commandbitstype = Command_bits_type[@gen.commandbits]
    commandbitsgetter = Command_bits_getter[@gen.commandbits]
    svcon = @gen.serverconnection.to_s
    out = "/* Generated by #{ToolName} */\n"
    out+= "#define _#{uprotoname}_SV_C_\n"
    out+= "#include \"#{@gen.protocolname}_sv.h\"\n"
    out+= "\n\n"
    out+= "typedef struct #{@gen.protocolname}_t_\n"
    out+= "{\n"
    out+= "  int count;\n"
    out+= "  VCEI64 next;\n"
    out+= "}#{@gen.protocolname}_t;\n"
    out+= "\n"
    out+= "static #{svcon}_t #{@gen.protocolname}_conns[#{uprotoname}_MAX_CONNECTION];\n"
    out+= "static int #{@gen.protocolname}_uninit=1;\n\n"
    out+= "#{@server_connvardef.join('')}\n"
    out+= "\n\n"
    out+= "#{@server_cntvardef.join('')}\n"
    out+= "#ifdef GEN_DEBUG_PRINT\n"
    out+= "#{@server_ddvardef.join('')}\n"
    out+= "#endif\n"
    out+= "\n\n"

    out+= "int #{@gen.protocolname}_get_using_index(#{svcon}_t c)\n"
    out+= "{\n"
    out+= "  int i;\n"
    out+= "  if(#{@gen.protocolname}_uninit)\n"
    out+= "  {\n"
    out+= "        for(i=0;i<#{uprotoname}_MAX_CONNECTION;i++)\n"
    out+= "    {\n"
    out+= "      #{@gen.protocolname}_conns[i].p=0;\n"
    out+= "      #{@gen.protocolname}_conns[i].serial=0;\n"
    out+= "    }\n"
    out+= "    #{@gen.protocolname}_uninit=0;\n"
    out+= "  }\n"
    out+= "  for(i=0;i<#{uprotoname}_MAX_CONNECTION;i++)\n"
    out+= "  {\n"
    out+= "    if(vce_#{svcon}_is_equal(c,#{@gen.protocolname}_conns[i]))\n"
    out+= "      return i;\n"
    out+= "  }\n"
    out+= "  return -1;\n"
    out+= "}\n"
    out+= "\n"
    
    out+= "int #{@gen.protocolname}_get_free_index()\n"
    out+= "{\n"
    out+= "  int i;\n"
    out+= "  if(#{@gen.protocolname}_uninit)\n"
    out+= "  {\n"
    out+= "    for(i=0;i<#{uprotoname}_MAX_CONNECTION;i++)\n"
    out+= "    {\n"
    out+= "      #{@gen.protocolname}_conns[i].p=0;\n"
    out+= "      #{@gen.protocolname}_conns[i].serial=0;\n"
    out+= "    }\n"
    out+= "    #{@gen.protocolname}_uninit=0;\n"
    out+= "  }\n"
    out+= "  for(i=0;i<#{uprotoname}_MAX_CONNECTION;i++)\n"
    out+= "  {\n"
    out+= "    if(#{@gen.protocolname}_conns[i].p==0&&#{@gen.protocolname}_conns[i].serial==0)\n"
    out+= "      return i;\n"
    out+= "  }\n"
    out+= "  return -1;\n"
    out+= "}\n"
    out+= "\n"
    
    out+= "int #{@gen.protocolname}_new(#{svcon}_t c)\n"
    out+= "{\n"
    out+= "  int index;\n"
    out+= "  VCEI64 next;\n"
    out+= "  index=#{@gen.protocolname}_get_free_index();\n"
    out+= "  if(index==-1)return -1;\n"
    out+= "  #{@gen.protocolname}_conns[index].p=c.p;\n"
    out+= "  #{@gen.protocolname}_conns[index].serial=c.serial;\n"
    out+= "  next=vce_get_current_utime();\n"
    out+= "#{@server_connvarinit.join('')}\n"
    out+= "  return 0;\n"
    out+= "}\n"
    out+= "\n"
    
    out+= "int #{@gen.protocolname}_del(#{svcon}_t c)\n"
    out+= "{\n"
    out+= "  int index;\n"
    out+= "  index=#{@gen.protocolname}_get_using_index(c);\n"
    out+= "  if(index==-1)return -1;\n"
    out+= "  #{@gen.protocolname}_conns[index].p=0;\n"
    out+= "  #{@gen.protocolname}_conns[index].serial=0;\n"
    out+= "  return 0;\n"
    out+= "}\n"
    out+= "\n"
    
    out+= "int #{@gen.protocolname}_manycall_check(#{@gen.protocolname}_t *many,int limit,VCEI64 time)\n"
    out+= "{\n"
    out+= "  VCEI64 currenttime=vce_get_current_utime();\n"
    out+= "  many->count++;\n"
    out+= "  while(many->next<currenttime)\n"
    out+= "  {\n"
    out+= "    many->count--;\n"
    out+= "    if(many->count==0)\n"
    out+= "    {\n"
    out+= "      many->next=currenttime+time;\n"
    out+= "      break;\n"
    out+= "    }\n"
    out+= "    many->next+=time;\n"
    out+= "  }\n"
    out+= "  if(many->count>limit)\n"
    out+= "  {\n"
    out+= "    many->count=limit;\n"
    out+= "    return -1;\n"
    out+= "  }\n"
    out+= "  return 0;\n"
    out+= "}\n"
    out+= "#define _SHORTCHECK if( _ofs<0  ){ if( _ofs != VCE_ETOOSHORT ){ return #{@gen.protocolname}_sv_recv_error_callback(_c, _ofs); } else { return 0; }}\n"


    out+= "#define _POP_I8(i) _ofs = vce_binary_pop_nb_i8(_data,_len,_ofs, (VCEI64*)&i); _SHORTCHECK;\n"
    out+= "#define _POP_I4(i) _ofs = vce_binary_pop_nb_i4(_data,_len,_ofs, (int*)&i); _SHORTCHECK;\n"
    out+= "#define _POP_I2(i) _ofs = vce_binary_pop_nb_i2(_data,_len,_ofs, (short*)&i); _SHORTCHECK;\n"
    out+= "#define _POP_I1(i) _ofs = vce_binary_pop_nb_i1(_data,_len,_ofs, (char*)&i); _SHORTCHECK;\n"
    out+= "#define _POP_F4(i) _ofs = vce_binary_pop_nb_i4(_data,_len,_ofs, (int*)&i); _SHORTCHECK;\n"
    out+= "#define _POP_IA8(ia,ialen) _ofs = vce_binary_pop_nb_ia8(_data,_len,_ofs,(VCEI64*)ia,&ialen); _SHORTCHECK;\n"
    out+= "#define _POP_IA4(ia,ialen) _ofs = vce_binary_pop_nb_ia4(_data,_len,_ofs,(int*)ia,&ialen); _SHORTCHECK;\n"
    out+= "#define _POP_IA2(ia,ialen) _ofs = vce_binary_pop_nb_ia2(_data,_len,_ofs,(short*)ia,&ialen); _SHORTCHECK;\n"
    out+= "#define _POP_IA1(ia,ialen) _ofs = vce_binary_pop_nb_ia1(_data,_len,_ofs,(char*)ia,&ialen); _SHORTCHECK;\n"
    out+= "#define _POP_FA4(ia,ialen) _ofs = vce_binary_pop_nb_ia4(_data,_len,_ofs,(int*)ia,&ialen); _SHORTCHECK;\n"
    out+= "#define _POP_STRA(sa,salen,eachmax,i,p) for(i=0;i<salen;i++){p[i]=sa[i];} _ofs = vce_binary_pop_nb_stra(_data,_len,_ofs,p,&salen,eachmax); _SHORTCHECK;\n"
    out+= "#ifdef GEN_DEBUG_PRINT\n"
    out+= "static void _make_debug_print_str( char *out, int outlen, char *in, int inlen )\n"
    out+= "{\n"
    out+= "  int i;\n"
    out+= "  int is_bin = 0;\n"
    out+= "  for( i=0; i<inlen; i++ ){\n"
    out+= "    if( in[i] < 0x20 || in[i] > 0x7E ){\n"
    out+= "      is_bin = 1;\n"
    out+= "      break;\n"
    out+= "    }\n"
    out+= "  }\n"
    out+= "  if( is_bin ){ \n"
    out+= "    vce_snprintf( out, outlen, \"(%d bytes)\", inlen ); \n"
    out+= "  }else{\n"
    out+= "    vce_makecstr( out, outlen, in, inlen );\n"
    out+= "  }\n"
    out+= "}\n"
    out+= "#endif //GEN_DEBUG_PRINT\n"
    out+= "static #{svcon}_t #{@gen.protocolname}_sv_current_#{svcon};\n"
    out+= "int #{@gen.protocolname}_sv_pcallback( #{svcon}_t _c, char *_data, int _len)\n"
    out+= "{\n"
    out+= "  int _ofs = #{@gen.commandbits};\n"
    out+= "  int _ret;\n"
# 回数を数えるのがおもすぎる。
#    out+= "  int _con_index;\n"
    out+= "  #{commandbitstype} _command;\n"
    out+= "  if( _len < #{@gen.commandbits} ) return 0;\n"
    out+= "  #{@gen.protocolname}_sv_current_#{svcon} = _c;\n"
#    out+= "  _con_index=#{@gen.protocolname}_get_using_index(_c);\n"
    out+= "  _command = #{commandbitsgetter}(_data);\n"
    out+= "  switch( _command ){\n"
    out+= "#{@server_recvcasedef.join('')}\n"
    out+= "  default: \n"
    out+= "    return #{@gen.protocolname}_sv_recv_error_callback(_c, VCE_EGENCOMMAND );\n"
    out+= "  }\n"
    out+= "  vce_#{svcon}_clear( &#{@gen.protocolname}_sv_current_#{svcon} );\n"
    out+= "  return _ret;\n"
    out+= "}\n\n"
    out+= "#define _OFSCHECK if( _ofs<0 ) return _ofs;\n"
    out+= "#define _LENCHECK(l,max) if( (l) > (max) ) return VCE_EFULL;\n"
      out+= "#define _PUSH_STRA(a,alen,maxalen,outmax,eachmax) _LENCHECK(alen,maxalen); _ofs = vce_binary_push_nb_stra(_work,_ofs,outmax,(const char*const*)a,alen,eachmax); _OFSCHECK;\n"

    out+= "#define _PUSH_IA1(a,alen,maxalen,outmax) _LENCHECK(alen,maxalen); _ofs = vce_binary_push_nb_ia1(_work,_ofs, outmax, a, alen ); _OFSCHECK;\n"
    out+= "#define _PUSH_IA2(a,alen,maxalen,outmax) _LENCHECK(alen,maxalen); _ofs = vce_binary_push_nb_ia2(_work,_ofs, outmax, a, alen ); _OFSCHECK;\n"
    out+= "#define _PUSH_IA4(a,alen,maxalen,outmax) _LENCHECK(alen,maxalen); _ofs = vce_binary_push_nb_ia4(_work,_ofs, outmax, a, alen ); _OFSCHECK;\n"
    out+= "#define _PUSH_IA8(a,alen,maxalen,outmax) _LENCHECK(alen,maxalen); _ofs = vce_binary_push_nb_ia8(_work,_ofs, outmax, a, alen ); _OFSCHECK;\n"
    out+= "#define _PUSH_FA4(a,alen,maxalen,outmax) _LENCHECK(alen,maxalen); _ofs = vce_binary_push_nb_ia4(_work,_ofs, outmax, (int *)a, alen ); _OFSCHECK;\n"
    out+= "#define _PUSH_I1(i,outmax) _ofs = vce_binary_push_nb_i1(_work,_ofs,outmax,(char)i); _OFSCHECK;\n"
    out+= "#define _PUSH_I2(i,outmax) _ofs = vce_binary_push_nb_i2(_work,_ofs,outmax,(short)i); _OFSCHECK;\n"
    out+= "#define _PUSH_I4(i,outmax) _ofs = vce_binary_push_nb_i4(_work,_ofs,outmax,(int)i); _OFSCHECK;\n"
    out+= "#define _PUSH_I8(i,outmax) _ofs = vce_binary_push_nb_i8(_work,_ofs,outmax,(VCEI64)i); _OFSCHECK;\n"
    out+= "#define _PUSH_F4(i,outmax) _ofs = vce_binary_push_nb_i4(_work,_ofs,outmax,*(int *)&i); _OFSCHECK;\n"

    out+= "#{@server_sendfuncdef.join('')}\n\n\n"
    out+= "#{@server_cntfuncdef.join('')}\n"
    out+= "#ifdef GEN_DEBUG_PRINT\n"
    out+= "#{@server_ddfuncdef.join('')}"
    out+= "#endif\n"
    out+= "unsigned int #{@gen.protocolname}_sv_get_version( unsigned int *subv )\n"
    out+= "{\n"
    out+= "  if(subv) *subv = #{@gen.subversion};\n"
    out+= "  return (unsigned int)#{@gen.version};\n"
    out+= "}\n"
    out+= "#{svcon}_t #{@gen.protocolname}_sv_get_current_#{svcon}( void )\n"
    out+= "{\n"
    out+= "  return #{@gen.protocolname}_sv_current_#{svcon};\n"
    out+= "}\n"
    out+= "/* End of generated code */\n"
    return out
  end
  def get_client_source
    uprotoname = @gen.protocolname.upcase
    commandbitstype = Command_bits_type[@gen.commandbits]
    commandbitsgetter = Command_bits_getter[@gen.commandbits]
    out = "/* Generated by #{ToolName} */\n"
    out+= "#define _#{uprotoname}_CLI_C_\n"
    out+= "#include \"#{@gen.protocolname}_cli.h\"\n"
    out+= "\n\n"
    out+= "#{@client_cntvardef.join('')}\n"
    out+= "#ifdef GEN_DEBUG_PRINT\n"
    out+= "#{@client_ddvardef.join('')}\n"
    out+= "#endif\n"
    out+= "\n\n"
    out+= "#define _SHORTCHECK if( _ofs<0  ){ if( _ofs != VCE_ETOOSHORT ){ return #{@gen.protocolname}_cli_recv_error_callback(_c, _ofs); } else { return 0; }}\n"
    out+= "#define _POP_I8(i) _ofs = vce_binary_pop_nb_i8(_data,_len,_ofs, (VCEI64*)&i); _SHORTCHECK;\n"
    out+= "#define _POP_I4(i) _ofs = vce_binary_pop_nb_i4(_data,_len,_ofs, (int*)&i); _SHORTCHECK;\n"
    out+= "#define _POP_I2(i) _ofs = vce_binary_pop_nb_i2(_data,_len,_ofs, (short*)&i); _SHORTCHECK;\n"
    out+= "#define _POP_I1(i) _ofs = vce_binary_pop_nb_i1(_data,_len,_ofs, (char*)&i); _SHORTCHECK;\n"
    out+= "#define _POP_F4(i) _ofs = vce_binary_pop_nb_i4(_data,_len,_ofs, (int*)&i); _SHORTCHECK;\n"
    out+= "#define _POP_IA8(ia,ialen) _ofs = vce_binary_pop_nb_ia8(_data,_len,_ofs,(VCEI64*)ia,&ialen); _SHORTCHECK;\n"
    out+= "#define _POP_IA4(ia,ialen) _ofs = vce_binary_pop_nb_ia4(_data,_len,_ofs,(int*)ia,&ialen); _SHORTCHECK;\n"
    out+= "#define _POP_IA2(ia,ialen) _ofs = vce_binary_pop_nb_ia2(_data,_len,_ofs,(short*)ia,&ialen); _SHORTCHECK;\n"
    out+= "#define _POP_IA1(ia,ialen) _ofs = vce_binary_pop_nb_ia1(_data,_len,_ofs,(char*)ia,&ialen); _SHORTCHECK;\n"
    out+= "#define _POP_FA4(ia,ialen) _ofs = vce_binary_pop_nb_ia4(_data,_len,_ofs,(int*)ia,&ialen); _SHORTCHECK;\n"
    out+= "#define _POP_STRA(sa,salen,eachmax,i,p) for(i=0;i<salen;i++){p[i]=sa[i];} _ofs = vce_binary_pop_nb_stra(_data,_len,_ofs,p,&salen,eachmax); _SHORTCHECK;\n"	
    out+= "#ifdef GEN_DEBUG_PRINT\n"
    out+= "static void _make_debug_print_str( char *out, int outlen, char *in, int inlen )\n"
    out+= "{\n"
    out+= "  int i;\n"
    out+= "  int is_bin = 0;\n"
    out+= "  for( i=0; i<inlen; i++ ){\n"
    out+= "    if( in[i] < 0x20 || in[i] > 0x7E ){\n"
    out+= "      is_bin = 1;\n"
    out+= "      break;\n"
    out+= "    }\n"
    out+= "  }\n"
    out+= "  if( is_bin ){ \n"
    out+= "    vce_snprintf( out, outlen, \"(%d bytes)\", inlen ); \n"
    out+= "  }else{\n"
    out+= "    vce_makecstr( out, outlen, in, inlen );\n"
    out+= "  }\n"
    out+= "}\n"
    out+= "#endif //GEN_DEBUG_PRINT\n"
    out+= "static conn_t #{@gen.protocolname}_cli_current_conn;\n"
    out+= "int #{@gen.protocolname}_cli_pcallback( conn_t _c, char *_data, int _len)\n"
    out+= "{\n"
    out+= "  int _ofs = #{@gen.commandbits};\n"
    out+= "  int _ret;\n"
    out+= "  #{commandbitstype} _command;\n"
    out+= "  if( _len < #{@gen.commandbits} ) return 0;\n"
    out+= "  #{@gen.protocolname}_cli_current_conn = _c;\n"
    out+= "  _command = #{commandbitsgetter}(_data);\n"
    out+= "  switch( _command ){\n"
    out+= "#{@client_recvcasedef.join('')}\n"
    out+= "  default:\n"
    out+= "    _ret = #{@gen.protocolname}_cli_recv_error_callback(_c,VCE_EGENCOMMAND);\n"
    out+= "  }\n"
    out+= "  vce_conn_clear( &#{@gen.protocolname}_cli_current_conn );\n"
    out+= "  return _ret;\n"
    out+= "}\n\n"
    out+= "#define _OFSCHECK if( _ofs<0 ) return _ofs;\n"
    out+= "#define _LENCHECK(l,max) if( (l) > (max) ) return VCE_EFULL;\n"
    out+= "#define _PUSH_STRA(a,alen,maxalen,outmax,eachmax) _LENCHECK(alen,maxalen); _ofs = vce_binary_push_nb_stra(_work,_ofs,outmax,(const char*const*)a,alen,eachmax)\n"

    out+= "#define _PUSH_IA1(a,alen,maxalen,outmax) _LENCHECK(alen,maxalen); _ofs = vce_binary_push_nb_ia1(_work,_ofs, outmax, (char*)a, alen ); _OFSCHECK;\n"
    out+= "#define _PUSH_IA2(a,alen,maxalen,outmax) _LENCHECK(alen,maxalen); _ofs = vce_binary_push_nb_ia2(_work,_ofs, outmax, (short*)a, alen ); _OFSCHECK;\n"
    out+= "#define _PUSH_IA4(a,alen,maxalen,outmax) _LENCHECK(alen,maxalen); _ofs = vce_binary_push_nb_ia4(_work,_ofs, outmax, (int*)a, alen ); _OFSCHECK;\n"
    out+= "#define _PUSH_IA8(a,alen,maxalen,outmax) _LENCHECK(alen,maxalen); _ofs = vce_binary_push_nb_ia8(_work,_ofs, outmax, (VCEI64*)a, alen ); _OFSCHECK;\n"
    out+= "#define _PUSH_FA4(a,alen,maxalen,outmax) _LENCHECK(alen,maxalen); _ofs = vce_binary_push_nb_ia4(_work,_ofs, outmax, (int*)a, alen ); _OFSCHECK;\n"
    out+= "#define _PUSH_I1(i,outmax) _ofs = vce_binary_push_nb_i1(_work,_ofs,outmax,(char)i); _OFSCHECK;\n"
    out+= "#define _PUSH_I2(i,outmax) _ofs = vce_binary_push_nb_i2(_work,_ofs,outmax,(short)i); _OFSCHECK;\n"
    out+= "#define _PUSH_I4(i,outmax) _ofs = vce_binary_push_nb_i4(_work,_ofs,outmax,(int)i); _OFSCHECK;\n"
    out+= "#define _PUSH_I8(i,outmax) _ofs = vce_binary_push_nb_i8(_work,_ofs,outmax,(VCEI64)i); _OFSCHECK;\n"
    out+= "#define _PUSH_F4(i,outmax) _ofs = vce_binary_push_nb_i4(_work,_ofs,outmax,*(int *)&i); _OFSCHECK;\n"



    out+= "#{@client_sendfuncdef.join('')}\n"
    out+= "#{@client_cntfuncdef.join('')}\n"
    out+= "#ifdef GEN_DEBUG_PRINT\n"
    out+= "#{@client_ddfuncdef.join('')}\n"
    out+= "#endif\n"
    out+= "unsigned int #{@gen.protocolname}_cli_get_version( unsigned int *subv )\n"
    out+= "{\n"
    out+= "  if(subv)*subv= #{@gen.subversion};\n"
    out+= "  return (unsigned int)#{@gen.version};\n"
    out+= "}\n"
    out+= "conn_t #{@gen.protocolname}_cli_get_current_conn( void )\n"
    out+= "{\n"
    out+= " return #{@gen.protocolname}_cli_current_conn;\n"
    out+= "}\n"
    out+= "/* End of generated code */\n"
    return out
  end
  
  def get_server_test_source
    out = "/* Generated by #{ToolName} */\n"
    out+= "/* Sorry, now server test source is not implemented. */\n"
    out+= "/* End of generated code */\n"
  end

  # 試しのデータを何となく送ってみる関数を適当に製作する
  #
  def get_sample_send_funcdef( name, argdef )
    if( argdef.size == 0 ) then
      return "#{@gen.protocolname}_#{name}_send( _c );\n"
    end
    out = "#{@gen.protocolname}_#{name}_send( _c, "
    out_args_ary = []
    argdef.each { |i|
      vtype = i["type"].to_s
      # single 変数だったら，1を，配列だったら NULL,0 を．
      if( vtype == "single" ) then
        out_args_ary.push( "1" )
      else
        out_args_ary.push( "NULL,0" )
      end
    }
    out += out_args_ary.join(",") + ");\n"
  end

  # C言語の受信用関数を出力する．
  # テストプログラム用．
  def get_sample_recv_funcdef( name, argdef )
    pr = make_ptype( "recv", name, argdef, nil )
    out = "/****/\n"
    out+= "#{pr}\n"
    out+= "{\n"
    out+= "    vce_errout( \"received #{name} from server\\n\" );\n"
    out+= "    return 0;\n"
    out+= "}\n"
  end

  def get_client_test_source
    uprotoname = @gen.protocolname.upcase
    lprotoname = @gen.protocolname
    out = "/* Generated by #{ToolName} */\n"
    out+= "#define _#{uprotoname}_CLI_TEST_C_\n"
    out+= "#include \"#{@gen.protocolname}_cli.h\"\n"
    out+= "\n\n"
    out+= "unsigned short portnum = 12345;\n"
    out+= "char *host = \"localhost\";\n"
    out+= "VCE_BLOCK_CIPHER cipher = VCE_BLOCK_CIPHER_NONE;\n"
    out+= "conn_t _c;\n"
    out+= "tcpcontext_t tcp;\n"
    out+= "int sent = 0;\n"
    out+= "\n"
    out+= "int #{lprotoname}_cli_sender( conn_t _c, char *data, int len )\n"
    out+= "{\n"
    out+= "    /* unparser: you may have to replace */\n"
    out+= "    return vce_protocol_unparser_bin32(_c,data,len);\n"
    out+= "}\n"
    out+= "int #{lprotoname}_cli_recv_error_callback( conn_t _c, int e )\n"
    out+= "{\n"
    out+= "    vce_errout( \"detected protocol error: %d\\n\",e);\n"
    out+= "    return -1;\n"
    out+= "}\n"
    out+= "#{@client_samplerecvfuncdef}\n"
    out+= "int main( int argc, char **argv )\n"
    out+= "{\n"
    out+= "    vce_initialize();\n"
    out+= "    vce_set_verbose_mode(0);\n"
    out+= "    if( argc != 3 ){\n"
    out+= "        vce_errout( \"Usage: #{lprotoname}_testcli host port\\n\" );\n"
    out+= "        return 1;\n"
    out+= "    }\n"
    out+= "    host = argv[1];\n"
    out+= "    portnum = (unsigned short) atoi( argv[2] );\n"
    out+= "    tcp = vce_tcpcontext_create( 0, \n"
    out+= "                                 NULL, 0, 1,\n"
    out+= "                                 #{@gen.workbufsize},\n"
    out+= "                                 #{@gen.workbufsize},\n"
    out+= "                                 9999999,\n"
    out+= "                                 VCE_BLOCK_CIPHER_NONE,0,\n"
    out+= "                                 0,0,0 );\n"
    out+= "    if( !tcp ){\n"
    out+= "        vce_errout( \"failed to create tcpcontext: %s\\n\", STRERR);\n"
    out+= "        return 1;\n"
    out+= "    }\n"
    out+= "    /* Here, you may want to replace bin32 parser */\n"
    out+= "    vce_tcpcontext_set_conn_parser( tcp,\n"
    out+= "                                    vce_protocol_parser_bin32,\n"
    out+= "                                    #{lprotoname}_cli_pcallback);\n"
    out+= "    _c = vce_tcpcontext_connect( tcp, host, portnum );\n"
    out+= "    if( vce_conn_is_valid(_c) == 0 ){\n"
    out+= "        vce_errout( \"failed to connect to server:%s\\n\",STRERR);\n"
    out+= "        return 1;\n"
    out+= "    }\n"
    out+= "    while(1){\n"
    out+= "        vce_heartbeat();\n"
    out+= "        if( vce_conn_is_valid(_c) == 0 ){\n"
    out+= "            vce_errout( \"connection lost\\n\" );\n"
    out+= "            exit(1);\n"
    out+= "        }\n"
    out+= "        if( vce_conn_writable(_c)>0 && sent == 0 ){\n"
    out+= "            /* Here you put your own protocol calls */\n"
    out+= "            #{@client_samplesendfuncdef[0]}\n"
    out+= "            sent = 1;\n"
    out+= "        }\n"
    out+= "    }\n"
    out+= "    /* not reached */\n"
    out+= "    return 0;\n"
    out+= "}\n"
    out+= "/* End of generated code */\n"
  end

  def shorttype2longtype(type)
      type = type.to_s
      if( type == "uchar" ) then
          return "unsigned char"
      elsif( type == "ushort" ) then
          return "unsigned short"
      elsif( type == "uint" ) then
          return "unsigned int"
      elsif( type == "int64" ) then
          return "VCEI64"
      else
          return type
      end
  end

end

# cpp 用クラス
class Genmaker_cpp < Genmaker_c
  def initialize( gen, sv, cli, testsv, testcli, testrecvcli, use_const )
    super( gen, sv, cli, testsv, testcli, testrecvcli, use_const )
  end
  def extention
    "cpp"
  end
end


#
# gen_maker_rb.rb
#
#
# Copyright (C) 2000-2005 Community Engine Inc. All rights reserved.
# For more information, please visit our website at www.ce-lab.net.
#


# ruby用ソースを出力する実装のクラス
class Genmaker_rb < Genmaker::Abstract
  Command_bits_getter = { 1 =>"pop_nb_i1!", 2 =>"pop_nb_i2!", 4 => "pop_nb_i4!"}
  Command_bits_setter = { 1 =>"push_nb_i1!", 2 =>"push_nb_i2!", 4 => "push_nb_i4!"}
  def initialize( gen, sv, cli, testsv, testcli, testrecvcli )
    super( gen, sv, cli, testsv, testcli, testrecvcli )
  end
  def extention
    "rb"
  end
  def get_popper(type,vartype,name,num)
    data = {
      "single.char" => "pop_nb_i1!",
      "single.uchar" => "pop_nb_i1!",
      "single.short" => "pop_nb_i2!",
      "single.ushort" => "pop_nb_i2!",
      "single.int" => "pop_nb_i4!",
      "single.uint" => "pop_nb_i4!",
      "single.int64" => "pop_nb_i8!",
      "array.char" => "pop_nb_ia1!",
      "array.uchar" => "pop_nb_ia1!",
      "array.short" => "pop_nb_ia2!",
      "array.ushort" => "pop_nb_ia2!",
      "array.int" => "pop_nb_ia4!",
      "array.uint" => "pop_nb_ia4!",
      "array.int64" => "pop_nb_ia8!",
      "array.char *" => "pop_nb_stra!" }
    r = data[ "#{type}.#{vartype}" ]
#    raise "bad type and vartype '#{type}.#{vartype}'" if( r == nil )
    return "#{name} = _data.#{r}(#{num})\n"
  end
  def get_pusher(type,vartype,name,num)
    data = {
      "single.char" => "push_nb_i1!",
      "single.uchar" => "push_nb_i1!",
      "single.short" => "push_nb_i2!",
      "single.ushort" => "push_nb_i2!",
      "single.int" => "push_nb_i4!",
      "single.uint" => "push_nb_i4!",
      "single.int64" => "push_nb_i8!",
      "array.char" => "push_nb_ia1!",
      "array.uchar" => "push_nb_ia1!",
      "array.short" => "push_nb_ia2!",
      "array.ushort" => "push_nb_ia2!",
      "array.int" => "push_nb_ia4!",
      "array.uint" => "push_nb_ia4!",
      "array.int64" => "push_nb_ia8!",
      "array.char *" => "push_nb_stra!" }
    r = data[ "#{type}.#{vartype}" ]
#    raise "bad type and vartype '#{type}.#{vartype}'" if( r == nil )
    if type == "single" then
      cast = ".to_i"
    elsif type == "array" && vartype == "char"
      cast = ".to_s"
    end
    return "_work.#{r}( #{name}#{cast} )\n"
  end

  # そのruby版。 iovar はいらないよ
  def make_ptype( action, name, argdef, con = nil)
    if argdef.size == 0 then
      return "#{@gen.protocolname}_#{name}_#{action}( _c )"
    else
      out = "#{@gen.protocolname}_#{name}_#{action}( _c, "
      append = []
      argdef.each{|i|
        append.push i["name"].to_s
      }
      return out + append.join( ", ") + " )"
    end
  end
  def get_cnt_vardef( action, msgname)
    return "$#{@gen.protocolname}_#{msgname}_#{action}_counter = 0\n"
  end
  def get_cnt_funcdef( action, msgname)
    out = "def #{@gen.protocolname}_get_#{msgname}_#{action}_count()\n"
    out+= "  return $#{@gen.protocolname}_#{msgname}_#{action}_counter\n"
    out+= "end\n"
  end
  def get_sample_recv_funcdef( name, argdef )
    "# ruby get_sample_recv_funcdef is not implemented now\n"
    out = "def " + make_ptype( "recv", name, argdef) + "\n"
    out += "  print '#{name} ('\n"
    argdef.each{ |i|
      out += "  print \"#{i["name"]}=\",#{i["name"]},\",\"\n"
    }
    out += "  print \" )\\n\" \n"
    out += "  0\n"
    out += "end\n"
    return out
  end
  def get_sample_send_funcdef(name,argdef)
    "# ruby get_sample_send_funcdef is not implemented now\n"
  end

  def get_send_funcdef( name, argdef, id, sender, con = nil)
    out = "def " + make_ptype( "send", name, argdef) + "\n"
    out += "  _work = \"\"\n"
    if con and @gen.serverconnection == :circ and @gen.vpr then
      out += "  _work.push_nb_i1!( #{@gen.protocolid})\n"
    end
    out+= "  _work." + Command_bits_setter[@gen.commandbits] +"(#{id})\n"
	argdef.each{ |i|
      vtype = i["type"].to_s
      vnum = i["value"][0]
      if i['vartype'] == :string then
        vvartype = "char *"
      elsif i['vartype'] == :stringarray then
        vvartype = "char *"
      else
        vvartype = i['vartype'].to_s
      end
      vvartype.downcase!
      vname = i["name"].to_s
      out+= "  " + get_pusher(vtype,vvartype,vname,vnum)
    }
    out+= "  return #{@gen.protocolname}_#{sender}(_c, _work )\n"
    out+= "end\n"
    return out
  end

  # そのruby版。
  def get_recv_casedef( name, argdef, id,isclient, con = nil)
    if( argdef.size == 0 ) then
      return "  when #{id}\n    ret = #{@gen.protocolname}_#{name}_recv(_c)\n"
    end

    retcode = "  when #{id}\n"
    popcode = ""
    args = []
    argdef.each{ |i|
      vtype = i["type"].to_s
      vnum = i["value"][0]
      if i['vartype'] == :string then
        vvartype = "char *"
      elsif i['vartype'] == :stringarray then
        vvartype = "char *"
      else
        vvartype = i['vartype'].to_s
      end
      vvartype.downcase!
      vname = i["name"].to_s
      
      popcode += "      " + get_popper(vtype,vvartype,vname,vnum)
      args.push( vname )
    }
    argstr = args.join(",")
    retcode += popcode
    retcode += "    $#{@gen.protocolname}_#{name}_recv_counter += 1\n"
    retcode += "    ret = #{@gen.protocolname}_#{name}_recv(_c, #{argstr} )\n"
    return retcode
  end
  def get_recv( name, argdef)
    if( argdef.size == 0 ) then
      retcode = "def #{@gen.protocolname}_#{name}_recv(_c)\n"
      retcode += "\t$#{@gen.protocolname}_recvdata.pusn( { 'proto' => \"#{@gen.protocolname}_#{name}_recv\", 'args' =>{\"conn\"=>_c}})\n"
      retcode += "\t0\n"
      retcode += "end\n"
      return retcode
    end
    retcode = ""
    args = []
    argdef.each{ |i|
      vname = i["name"]
      args.push( vname )
    }
    argstr = args.join(",")
    retcode += "def #{@gen.protocolname}_#{name}_recv(_c, #{argstr} )\n"
    retcode += "\t$#{@gen.protocolname}_recvdata.push( { 'proto' => \"#{@gen.protocolname}_#{name}_recv\", 'args' =>{ \"conn\"=>_c"
    args.each do |a|
      retcode += ",\"#{a}\"=>#{a}"
    end
    retcode += "}})\n"
    retcode += "\t0\n"
    retcode += "end\n"
    return retcode
  end

  # それのRuby版
  def get_server_source
    defines = make_define_defs
    enums = make_enum_defs
    out = "# Generated by #{ToolName}\n"
    out+= "require \"vce.so\"\n"
    out+= "\n\n"
    uprotoname = @gen.protocolname.upcase
    out += "#{defines}"
    out += "#{enums}"
    out+= "#{@server_cntvardef}\n"
    out+= "$#{@gen.protocolname}_recvdata = []\n"
    out+= "\n\n"
    out+= "$#{@gen.protocolname}_sv_proc = Proc.new {|_c,_data|\n"
    out+= "  ret = 0\n"
    out+= "  break if( _data.length < #{@gen.commandbits} )\n"
    out+= "  _command = _data.pop_nb_i#{@gen.commandbits}!\n"
    out+= "  case _command\n"
    out+= "#{@server_recvcasedef}\n"
    out+= "  else\n"
    out+= "    ret = #{@gen.protocolname}_sv_recv_error_callback(_c, \"gencommand\" )\n"
    out+= "  end\n"
    out+= "  ret\n"
    out+= "}\n"
    out+= "#{@server_sendfuncdef}\n"
    out+= "#{@server_cntfuncdef}\n"
    out+= "\n"
    out+= "def #{@gen.protocolname}_sv_get_version()\n"
    out+= "  return [ #{@gen.version} , #{@gen.subversion} ]\n"
    out+= "end\n\n"
    out+= "# End of generated code\n"
    return out
  end

  # そのruby版
  def get_client_source
    defines = make_define_defs
    enums = make_enum_defs
    out = "# Generated by #{ToolName}\n"
    out+= "require \"vce.so\"\n"
    out+= "\n\n"
    uprotoname = @gen.protocolname.upcase
    out += "#{defines}"
    out += "#{enums}"
    out+= "#{@client_cntvardef}\n"
    out+= "$#{@gen.protocolname}_recvdata = []\n"
    out+= "\n\n"
    out+= "$#{@gen.protocolname}_cli_proc = Proc.new { |_c,_data|\n"
    out+= "  ret = 0\n"
    out+= "  break if( _data.length < #{@gen.commandbits} )\n"
    out+= "  _command = _data.pop_nb_i#{@gen.commandbits}!\n"
    out+= "  case _command\n"
    out+= "#{@client_recvcasedef}\n"
    out+= "  else\n"
    out+= "    ret = #{@gen.protocolname}_cli_recv_error_callback(_c,\"gencommand\")\n"
    out+= "  end\n"
    out+= "  ret\n"
    out+= "}\n"
    out+= "#{@client_recvfuncdef}\n"
    out+= "#{@client_sendfuncdef}\n"
    out+= "#{@client_cntfuncdef}\n"
    out+= "\n"
    out+= "def #{@gen.protocolname}_cli_get_version()\n"
    out+= "  return [ #{@gen.version} , #{@gen.subversion} ]\n"
    out+= "end\n\n"
    out+= "# End of generated code\n"
    return out
  end
  def get_server_test_source
    out = "# Generated by #{ToolName}\n"
    out += "# server test code is not implemented now in ruby\n"
    out += "# End of generated code\n"
  end
  def get_client_test_source
    out = "# Generated by #{ToolName}\n"
    out += "# client test code is not implemented now in ruby\n"
    out += "# End of generated code\n"

    out += <<-EOT
    # Generated by #{ToolName}
    require 'vce.so'
    require '#{@gen.protocolname}_cli.rb'
    def #{@gen.protocolname}_cli_recv_error_callback( c, e )
      print "detected protocol error: #{'#{c}'}\n"
      -1
    end
    #{@client_samplerecvfuncdef}
    def test_main( host, port )
      context = TCPcontext.create( FALSE, nil, 0, 1000, 
                                  #{@gen.workbufsize}, #{@gen.workbufsize},
                                  60*60, 1, 8, 0, 0 )
      context.set_conn_parser( Conn::PARSER_BIN16, $#{@gen.protocolname}_cli_proc )

      conn = context.connect( host, port )

      if !conn.valid?
        print "cannnot connect.\n"
        exit 1
      end
      
      Vce.heartbeat while true

    end
    EOT
    return out
  end
  def get_client_test_recv_source
    out = "# Generated by #{ToolName}\n"
    out += "require \"vce.so\"\n"
    out += "\n\n"
    out += "#{@client_test_recv}\n"
    out += "def #{@gen.protocolname}_cli_sender( _c, _data)\n"
    out += "\t_c.unparser_bin16( _data)\n"
    out += "end\n"
    out+= "# End of generated code\n"
    return out
  end
  def make_define_defs
    out = ""
    uprotoname = @gen.protocolname.upcase
    @gen.define.each do |define, num|
      out += "#{uprotoname}_#{define} = #{num}\n"
    end
    out
  end

  # enum の配列から，C言語の typedef つき enum 定義を作りだす．
  # 文字列を返す．
  def make_enum_defs
    enumhash = {}
    out = ""
    @gen.enum.each do |key, e|
      symbol = key.to_s
      enumtype, val = e[0..1]
      out += 
        "#{@gen.protocolname.upcase}_#{symbol.to_s} = #{val.to_s}\n"
    end
    return out
  end
end

#
# gen_footer.rb
#
#
# Copyright (C) 2000-2005 Community Engine Inc. All rights reserved.
# For more information, please visit our website at www.ce-lab.net.
#

###########################################################################
# 使い方
###########################################################################
def pusage
  print "Usage: ruby gen.rb [Options] infile\n"
  print "--protocolname NAME\n"
  print "--serverconnection CONTYPE\n"
  print "--workbufsize SIZE\n"
  print "--version NUMBER\n"
  print "--identifier STRING\n"
  print "--nocpp\n"
  print "--noc\n"
  print "--noruby(--norb)\n"
  print "--nocli\n"
  print "--nosv\n"
  print "--output_test_sv\n"
  print "--output_test_cli\n"
  print "--output_test_recv_cli\n"
  print "--use_const\n"
  print "These options are overridden by command line options.\n"
end

begin
  gen = Gen.new
  infile = nil
  
  no_cpp_source = false
  no_c_source = false
  no_ruby_source = false
  no_sv_source = false
  no_cli_source = false
  output_test_sv = false
  output_test_cli = false
  output_test_recv_cli = false
  use_const = true
  
  ##### オプション解析
  if( ARGV.size < 1 ) then
    pusage()
    exit 0
  else
    while ARGV.size > 0 
      op = ARGV.shift
      if( op =~ /^--/ ) then
        arg = ARGV.shift
        if( arg == nil ) then
          pusage()
          exit 0
        end
        case op
        when "--protocolname"
          gen.protocolname = arg
        when "--serverconnection"
          gen.serverconnection = arg
        when "--workbufsize"
          gen.workbufsize = arg.to_i
        when "--version"
          gen.version = arg.to_i
        when "--identifier"
          gen.identifier = arg
          
        when "--nocpp"
          no_cpp_source = true
          ARGV.unshift(arg)
        when "--noc"
          no_c_source = true
          ARGV.unshift(arg)
        when "--noruby"
          no_ruby_source = true
          ARGV.unshift(arg)
        when "--norb"
          no_ruby_source = true
          ARGV.unshift(arg)
        when "--nocli"
          no_cli_source = true
          ARGV.unshift(arg)
        when "--nosv"
          no_sv_source = true
          ARGV.unshift(arg)
        when "--output_test_sv"
          output_test_sv = true
          ARGV.unshift(arg)
        when "--output_test_cli"
          output_test_cli = true
          ARGV.unshift(arg)
        when "--output_test_recv_cli"
          output_test_recv_cli = true
          ARGV.unshift(arg)
        when "--use_const"
          use_const = true
          ARGV.unshift(arg)
        else
          pusage
          exit 0
        end
      else
        infile = op
      end
    end
  end

  ##### パース開始
  File.open( infile ) do |f|
    gen.parse( f, infile)
  end
  if no_c_source == false then
    # 文字列作成
    g = Genmaker::create( "c", gen, !no_sv_source, !no_cli_source, 
                         output_test_sv, output_test_cli, output_test_recv_cli, use_const )
    g.make
    # 保存
    g.save_file
  end
  if no_cpp_source == false then
    # 文字列作成
    g = Genmaker::create( "cpp", gen, !no_sv_source, !no_cli_source,
                         output_test_sv, output_test_cli, output_test_recv_cli, use_const )
    g.make
    # 保存
    g.save_file
  end
  if no_ruby_source == false then
    # 文字列作成
    g = Genmaker::create( "rb", gen, !no_sv_source, !no_cli_source,
                         output_test_sv, output_test_cli, output_test_recv_cli, use_const )
    g.make
    # 保存
    g.save_file
  end
rescue Racc::ParseError, Gen::GenError, Errno::ENOENT
  raise ####
  $stderr.puts "#{File.basename $0}: #{$!}"
  exit 1
end


